# Brainstorm: Agent Profiles

## Context

Antwort is an OpenResponses API gateway. The Responses API already has an `instructions` field for system prompts. Agent profiles extend this with persistent, reusable agent configurations that bundle instructions, tools, model preferences, sandbox policies, and memory settings.

This is the server-side equivalent of what OpenClaw does with its SOUL.md, IDENTITY.md, and USER.md files. But instead of local-only markdown files tied to a single developer, agent profiles are first-class API resources managed centrally by platform engineers and shared across teams.

## 1. Problem Statement

Today, every Responses API request must carry its full agent configuration inline:

```json
{
  "model": "llama-4",
  "instructions": "You are a security analyst specialized in CVE triage...",
  "tools": [
    {"type": "code_interpreter"},
    {"type": "file_search", "vector_store_ids": ["vs_vuln_db"]},
    {"type": "mcp", "server_url": "https://nvd.example.com/mcp"}
  ],
  "temperature": 0.2,
  "input": [{"role": "user", "content": "Analyze CVE-2025-1234"}]
}
```

This creates several problems:

**Duplication.** Enterprise teams running multiple agents (security analyst, data engineer, docs writer, DevOps assistant) copy-paste the same configuration block into every request. Instructions alone can be hundreds of lines. Tool configurations, sandbox policies, and memory settings add more bulk.

**No central management.** When the security team updates their analyst's instructions, every client application needs to be redeployed. There is no single source of truth for "what does our security analyst agent do?"

**No governance.** Platform engineers have no way to enforce that all agents use a specific sandbox policy, or that all agents connecting to production databases go through an approved MCP server. Each team configures agents independently.

**No version control.** When an agent's behavior changes, there is no audit trail. If an agent starts producing bad results, teams cannot roll back to a known-good configuration.

**No organizational sharing.** OpenClaw's markdown files are per-user and local-only. Team A's excellent security analyst configuration cannot be shared with Team B without manual file copying.

## 2. The Agent Profile Data Model

An agent profile is a complete, reusable agent configuration. Every field has a clear purpose and defined behavior when combined with per-request overrides.

### Full Data Model

```json
{
  "id": "agent_sec_analyst_7x9k2",
  "object": "agent_profile",
  "name": "security-analyst",
  "display_name": "Security Analyst",
  "description": "CVE triage and vulnerability analysis agent with access to NVD and internal vulnerability databases.",

  "instructions": "You are a senior security analyst at Acme Corp. Your job is to triage CVEs reported by automated scanners and produce actionable assessments.\n\nAlways:\n- Check the NVD database for CVSS scores\n- Cross-reference with our internal asset inventory\n- Classify severity as Critical, High, Medium, Low, or Informational\n- Recommend specific remediation steps\n- Flag any CVE affecting production systems as urgent\n\nNever:\n- Speculate about exploitability without evidence\n- Recommend ignoring a CVE without justification\n- Access systems outside the security tooling boundary",

  "model": "llama-4-maverick",

  "tools": [
    {
      "type": "code_interpreter",
      "sandbox_policy_id": "sbxpol_hardened_sec"
    },
    {
      "type": "file_search",
      "vector_store_ids": ["vs_vuln_db_2025", "vs_asset_inventory"],
      "max_num_results": 20,
      "ranking_options": {
        "ranker": "auto",
        "score_threshold": 0.6
      }
    },
    {
      "type": "mcp",
      "server_label": "nvd-api",
      "server_url": "https://nvd.internal.acme.com/mcp",
      "allowed_tools": ["search_cve", "get_cve_details", "list_affected_products"],
      "require_approval": "never"
    },
    {
      "type": "function",
      "name": "create_jira_ticket",
      "description": "Create a Jira ticket in the SEC project for tracking remediation",
      "parameters": {
        "type": "object",
        "properties": {
          "title": {"type": "string"},
          "severity": {"type": "string", "enum": ["Critical", "High", "Medium", "Low"]},
          "cve_id": {"type": "string"},
          "description": {"type": "string"}
        },
        "required": ["title", "severity", "cve_id"]
      }
    }
  ],

  "sandbox_policy_id": "sbxpol_hardened_sec",

  "memory": {
    "vector_store_ids": ["vs_vuln_db_2025", "vs_asset_inventory"],
    "conversation_retention_days": 90,
    "summary_enabled": true,
    "summary_model": "llama-4-scout"
  },

  "temperature": 0.2,
  "top_p": 0.9,
  "max_output_tokens": 4096,

  "metadata": {
    "team": "platform-security",
    "cost_center": "SEC-001",
    "compliance_level": "soc2",
    "owner_email": "security-team@acme.com"
  },

  "base_profile_id": null,

  "status": "active",
  "version": 3,
  "created_at": "2025-11-15T09:30:00Z",
  "updated_at": "2026-01-20T14:22:00Z",
  "created_by": "user_platform_admin_8k2j",
  "tenant_id": "tenant_acme_corp"
}
```

### Field-by-Field Specification

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `id` | string | auto | Auto-generated, prefixed `agent_`. Immutable after creation. |
| `object` | string | auto | Always `"agent_profile"`. Follows OpenAI object-type convention. |
| `name` | string | yes | Machine-readable identifier. Must be unique per tenant. Lowercase, hyphens, underscores only. Max 64 chars. |
| `display_name` | string | no | Human-readable name for UIs. |
| `description` | string | no | Free-text description of what this agent does. |
| `instructions` | string | yes | The system prompt. This is the "soul" of the agent. Can be multi-line, supports markdown formatting. Max 256KB. |
| `model` | string | no | Default model identifier. If omitted, uses the server's default model. Can be overridden per-request. |
| `tools` | array | no | Default tool configurations. Each entry follows the Responses API tool schema. Merged with per-request tools. |
| `sandbox_policy_id` | string | no | Reference to a sandbox policy (from Spec 11). Applies to all code execution tools unless overridden per-tool. |
| `memory` | object | no | Memory configuration for RAG and conversation retention. |
| `temperature` | float | no | Default sampling temperature (0.0 to 2.0). |
| `top_p` | float | no | Default nucleus sampling parameter. |
| `max_output_tokens` | int | no | Default max output tokens per response. |
| `metadata` | object | no | Arbitrary key-value pairs. Keys and values must be strings. Max 16 keys, max 512 chars per key/value. |
| `base_profile_id` | string | no | Parent profile ID for inheritance. See Section 5. |
| `status` | string | auto | `"active"` or `"archived"`. Only active profiles can be referenced. |
| `version` | int | auto | Incremented on every update. Used for optimistic concurrency. |
| `created_at` | string | auto | ISO 8601 timestamp. |
| `updated_at` | string | auto | ISO 8601 timestamp. |
| `created_by` | string | auto | Subject identifier of the creator (from auth Identity). |
| `tenant_id` | string | auto | Tenant isolation. Set from the authenticated identity. |

### Memory Configuration Object

```json
{
  "vector_store_ids": ["vs_vuln_db_2025"],
  "conversation_retention_days": 90,
  "summary_enabled": true,
  "summary_model": "llama-4-scout"
}
```

| Field | Type | Description |
|-------|------|-------------|
| `vector_store_ids` | array[string] | Vector stores for RAG retrieval. Used by file_search tool. |
| `conversation_retention_days` | int | How long stored conversations are kept. 0 means no retention. |
| `summary_enabled` | bool | Whether to generate conversation summaries for long-term memory. |
| `summary_model` | string | Model to use for summarization (can be a cheaper/faster model). |

## 3. The Side-API: /v1/agents

Agent profiles are managed through a standard CRUD API that lives alongside the Responses API. This is a "side-API" because it is not part of the OpenResponses specification itself, but it extends the platform's capabilities.

### POST /v1/agents

Create a new agent profile.

**Request:**

```http
POST /v1/agents
Authorization: Bearer sk-platform-admin-key
Content-Type: application/json

{
  "name": "data-engineer",
  "display_name": "Data Engineer",
  "description": "SQL analysis and data pipeline debugging agent",
  "instructions": "You are a data engineer at Acme Corp. You help analysts write and debug SQL queries against our Snowflake data warehouse.\n\nRules:\n- Always explain your query logic step by step\n- Use CTEs for complex queries, never nested subqueries deeper than 2 levels\n- Always include a LIMIT clause in exploratory queries\n- Never run DELETE or DROP statements\n- Reference our data dictionary when explaining column meanings",
  "model": "llama-4-maverick",
  "tools": [
    {
      "type": "code_interpreter",
      "sandbox_policy_id": "sbxpol_data_science"
    },
    {
      "type": "file_search",
      "vector_store_ids": ["vs_data_dictionary", "vs_sql_patterns"]
    }
  ],
  "temperature": 0.3,
  "max_output_tokens": 8192,
  "metadata": {
    "team": "data-platform",
    "cost_center": "DATA-002"
  }
}
```

**Response (201 Created):**

```json
{
  "id": "agent_data_eng_3m7p",
  "object": "agent_profile",
  "name": "data-engineer",
  "display_name": "Data Engineer",
  "description": "SQL analysis and data pipeline debugging agent",
  "instructions": "You are a data engineer at Acme Corp...",
  "model": "llama-4-maverick",
  "tools": [
    {
      "type": "code_interpreter",
      "sandbox_policy_id": "sbxpol_data_science"
    },
    {
      "type": "file_search",
      "vector_store_ids": ["vs_data_dictionary", "vs_sql_patterns"]
    }
  ],
  "sandbox_policy_id": null,
  "memory": null,
  "temperature": 0.3,
  "top_p": null,
  "max_output_tokens": 8192,
  "metadata": {
    "team": "data-platform",
    "cost_center": "DATA-002"
  },
  "base_profile_id": null,
  "status": "active",
  "version": 1,
  "created_at": "2026-02-22T10:15:00Z",
  "updated_at": "2026-02-22T10:15:00Z",
  "created_by": "user_admin_5k9x",
  "tenant_id": "tenant_acme_corp"
}
```

### GET /v1/agents

List agent profiles. Supports pagination and filtering.

**Request:**

```http
GET /v1/agents?status=active&limit=20&after=agent_data_eng_3m7p
Authorization: Bearer sk-platform-admin-key
```

**Query Parameters:**

| Parameter | Type | Description |
|-----------|------|-------------|
| `limit` | int | Max results per page (1-100, default 20) |
| `after` | string | Cursor for forward pagination (agent ID) |
| `before` | string | Cursor for backward pagination |
| `status` | string | Filter by status: `active`, `archived` |
| `name` | string | Filter by exact name match |
| `metadata.key` | string | Filter by metadata value (e.g., `metadata.team=security`) |

**Response (200 OK):**

```json
{
  "object": "list",
  "data": [
    {
      "id": "agent_sec_analyst_7x9k2",
      "object": "agent_profile",
      "name": "security-analyst",
      "display_name": "Security Analyst",
      "description": "CVE triage and vulnerability analysis agent",
      "status": "active",
      "version": 3,
      "created_at": "2025-11-15T09:30:00Z",
      "updated_at": "2026-01-20T14:22:00Z"
    },
    {
      "id": "agent_docs_writer_2n4q",
      "object": "agent_profile",
      "name": "docs-writer",
      "display_name": "Documentation Writer",
      "description": "Technical documentation agent",
      "status": "active",
      "version": 1,
      "created_at": "2026-02-01T08:00:00Z",
      "updated_at": "2026-02-01T08:00:00Z"
    }
  ],
  "has_more": false,
  "first_id": "agent_sec_analyst_7x9k2",
  "last_id": "agent_docs_writer_2n4q"
}
```

Note: The list endpoint returns a summary view. Full details (instructions, tools, memory) are only included when fetching a single profile by ID. This keeps list responses small and fast.

### GET /v1/agents/{id}

Get a single agent profile with all fields.

**Request:**

```http
GET /v1/agents/agent_sec_analyst_7x9k2
Authorization: Bearer sk-developer-key
```

**Response (200 OK):**

Full agent profile object as shown in the data model section above.

### PUT /v1/agents/{id}

Full replacement update. The entire profile is replaced with the request body. Fields not included revert to their defaults (null).

**Request:**

```http
PUT /v1/agents/agent_data_eng_3m7p
Authorization: Bearer sk-platform-admin-key
Content-Type: application/json
If-Match: 1

{
  "name": "data-engineer",
  "display_name": "Data Engineer v2",
  "description": "SQL analysis and data pipeline debugging agent with Snowflake integration",
  "instructions": "Updated instructions here...",
  "model": "llama-4-maverick",
  "tools": [
    {"type": "code_interpreter", "sandbox_policy_id": "sbxpol_data_science"},
    {"type": "file_search", "vector_store_ids": ["vs_data_dictionary", "vs_sql_patterns"]},
    {"type": "mcp", "server_label": "snowflake", "server_url": "https://snowflake.internal.acme.com/mcp"}
  ],
  "temperature": 0.3,
  "max_output_tokens": 8192,
  "metadata": {"team": "data-platform", "cost_center": "DATA-002"}
}
```

The `If-Match` header carries the expected version number. If the current version does not match, the server returns `409 Conflict`. This prevents lost updates when two admins edit the same profile concurrently.

**Response (200 OK):**

```json
{
  "id": "agent_data_eng_3m7p",
  "object": "agent_profile",
  "name": "data-engineer",
  "display_name": "Data Engineer v2",
  "version": 2,
  "updated_at": "2026-02-22T11:00:00Z",
  "...": "..."
}
```

### PATCH /v1/agents/{id}

Partial update. Only the fields included in the request body are modified.

**Request:**

```http
PATCH /v1/agents/agent_data_eng_3m7p
Authorization: Bearer sk-platform-admin-key
Content-Type: application/json
If-Match: 2

{
  "temperature": 0.1,
  "metadata": {
    "compliance_level": "hipaa"
  }
}
```

**Merge semantics for complex fields:**

- `tools`: The tools array is replaced entirely (not merged element-by-element). If you want to add a tool, send the full tools array.
- `metadata`: Metadata keys are merged. To remove a key, set it to `null`.
- `memory`: The memory object is replaced entirely.
- Scalar fields: Replaced directly.

**Response (200 OK):** Updated profile with incremented version.

### DELETE /v1/agents/{id}

Soft delete. Sets status to `"archived"`. The profile is no longer usable in new requests, but existing conversations that reference it continue to work (they pinned the version at conversation start).

**Request:**

```http
DELETE /v1/agents/agent_data_eng_3m7p
Authorization: Bearer sk-platform-admin-key
```

**Response (200 OK):**

```json
{
  "id": "agent_data_eng_3m7p",
  "object": "agent_profile",
  "status": "archived",
  "deleted": true
}
```

To permanently delete (hard delete), use `DELETE /v1/agents/{id}?permanent=true`. This is irreversible and requires the `agents:admin` scope.

### Error Responses

All errors follow the OpenResponses error format:

```json
{
  "error": {
    "type": "not_found",
    "message": "Agent profile 'agent_nonexistent' not found",
    "code": "agent_not_found"
  }
}
```

| Status | Error Type | When |
|--------|-----------|------|
| 400 | `invalid_request` | Malformed request body, invalid field values |
| 404 | `not_found` | Agent ID does not exist or belongs to different tenant |
| 409 | `conflict` | Version mismatch on PUT/PATCH (optimistic concurrency) |
| 409 | `conflict` | Duplicate name within tenant |
| 422 | `unprocessable_entity` | Valid JSON but semantic errors (e.g., referencing nonexistent sandbox policy) |

## 4. The Bridge: agent_id in Responses API

The agent profile system connects to the Responses API through a single new field: `agent_id`.

### Request Format

```json
{
  "model": "llama-4-maverick",
  "agent_id": "agent_sec_analyst_7x9k2",
  "input": [
    {
      "role": "user",
      "content": "Analyze CVE-2025-1234 and assess its impact on our infrastructure"
    }
  ]
}
```

### Resolution Logic

When the Responses API receives a request with `agent_id`, the following happens:

1. **Load profile.** Fetch the agent profile by ID, scoped to the authenticated tenant.
2. **Check status.** If the profile is archived, return `404`.
3. **Pin version.** Record the profile version in the conversation metadata (for ongoing conversations).
4. **Merge configuration.** Combine profile defaults with inline request fields.
5. **Execute.** Proceed with the merged configuration as if it had all been specified inline.

### Merge Precedence Rules

Inline request fields always override profile defaults. This lets developers use a profile as a base and customize per-request when needed.

| Field | Merge Behavior |
|-------|---------------|
| `model` | Inline wins. If both set, request model is used. |
| `instructions` | Inline wins. If both set, request instructions replace profile instructions entirely. They are NOT concatenated. |
| `tools` | **Additive.** Profile tools and request tools are combined. If both specify the same tool type (e.g., two `code_interpreter` entries), the request version takes precedence. |
| `temperature` | Inline wins. |
| `top_p` | Inline wins. |
| `max_output_tokens` | Inline wins. |

The additive behavior for tools is important. A profile might define the baseline tools (code_interpreter, file_search with company vector stores), and a specific request might add a one-off MCP connection. The result is the union of both tool sets.

### Example: Profile + Override

**Profile defines:**
- model: `llama-4-maverick`
- temperature: 0.2
- tools: `[code_interpreter, file_search]`

**Request specifies:**
- model: `llama-4-scout` (overrides)
- temperature: (not specified, uses profile default 0.2)
- tools: `[mcp:github]` (added to profile tools)

**Merged result:**
- model: `llama-4-scout`
- temperature: 0.2
- tools: `[code_interpreter, file_search, mcp:github]`

### Backward Compatibility

If `agent_id` is not present in the request, everything works exactly as before. The request is self-contained and no profile lookup happens. This means agent profiles are a pure addition with zero breaking changes.

### Tenant Scoping

Agent profile resolution is always scoped to the authenticated tenant. Tenant A cannot reference Tenant B's agent profiles, even if they know the ID. The lookup query always includes `WHERE tenant_id = ?`.

## 5. Agent Templates and Inheritance

### The Problem

Large organizations want consistency across agents. Every agent should:
- Use approved MCP servers for internal systems
- Follow security-mandated sandbox policies
- Include standard compliance disclaimers in instructions

Without inheritance, platform engineers must duplicate these settings across every agent profile and keep them synchronized manually.

### Base Profiles

An agent profile can reference a `base_profile_id` to inherit configuration from a parent profile.

```json
{
  "id": "agent_base_acme_9x2k",
  "name": "acme-base",
  "description": "Base profile for all Acme Corp agents. Do not use directly.",
  "instructions": "You are an AI assistant at Acme Corp. Always follow these policies:\n- Never share internal data outside the organization\n- Always cite sources when referencing internal documents\n- If unsure, say so explicitly rather than guessing",
  "tools": [
    {
      "type": "mcp",
      "server_label": "internal-search",
      "server_url": "https://search.internal.acme.com/mcp"
    }
  ],
  "sandbox_policy_id": "sbxpol_standard",
  "temperature": 0.5,
  "metadata": {
    "profile_type": "base",
    "managed_by": "platform-team"
  }
}
```

A child profile extends the base:

```json
{
  "id": "agent_sec_analyst_7x9k2",
  "name": "security-analyst",
  "base_profile_id": "agent_base_acme_9x2k",
  "instructions": "You are a senior security analyst at Acme Corp...",
  "tools": [
    {
      "type": "code_interpreter",
      "sandbox_policy_id": "sbxpol_hardened_sec"
    },
    {
      "type": "file_search",
      "vector_store_ids": ["vs_vuln_db_2025"]
    }
  ],
  "temperature": 0.2
}
```

### Inheritance Resolution

When a profile with `base_profile_id` is loaded, the merge happens in order: base first, then child overrides.

| Field | Inheritance Behavior |
|-------|---------------------|
| `instructions` | **Concatenation.** Base instructions come first, then child instructions, separated by a blank line. This is different from request-level override (which replaces). |
| `tools` | **Append.** Child tools are appended to base tools. Duplicates (same type and configuration) are deduplicated. |
| `sandbox_policy_id` | Child wins if set. Otherwise base value is used. |
| `model` | Child wins if set. |
| `temperature`, `top_p`, `max_output_tokens` | Child wins if set. |
| `memory` | Child wins if set (full replacement, not merge). |
| `metadata` | **Merge.** Child metadata keys are merged with base metadata. Child values override base values for the same key. |

The instruction concatenation is a deliberate design choice. It ensures that organizational policies in the base profile are always included, even when a child profile defines its own personality and rules. Platform engineers can enforce "every agent says this" by putting it in the base.

### Inheritance Depth

Maximum inheritance depth is 3 levels (base -> child -> grandchild). Deeper hierarchies create debugging nightmares. If someone needs more than 3 levels, they should flatten their configuration.

### Resolved View

The `GET /v1/agents/{id}` endpoint can return either the raw profile or the fully resolved (flattened) view:

```http
GET /v1/agents/agent_sec_analyst_7x9k2?resolve=true
```

The resolved view shows the effective configuration after all inheritance is applied. This is what the Responses API actually uses when processing a request.

## 6. Versioning and Rollback

### Version Tracking

Every update to an agent profile increments the `version` field. The version is a simple integer counter, not a semantic version.

```
Version 1: Initial creation (security analyst with basic tools)
Version 2: Added NVD MCP server
Version 3: Updated instructions with new compliance requirements
```

### Version History Storage

Old versions are preserved in a separate table. This enables:
- **Audit trail**: See what changed and when
- **Rollback**: Restore a previous version
- **Conversation consistency**: Pin conversations to a specific version

```json
{
  "id": "agent_sec_analyst_7x9k2",
  "version": 2,
  "snapshot": { "...full profile at version 2..." },
  "changed_by": "user_admin_5k9x",
  "changed_at": "2026-01-10T09:00:00Z",
  "change_summary": "Added NVD MCP server tool"
}
```

### Conversation Pinning

When a conversation starts with an `agent_id`, the Responses API records the agent version in the conversation metadata:

```json
{
  "id": "resp_abc123",
  "agent_id": "agent_sec_analyst_7x9k2",
  "agent_version": 3,
  "...": "..."
}
```

If the agent profile is updated to version 4 while a conversation is still active, subsequent requests in that conversation (via `previous_response_id`) continue to use version 3. This prevents mid-conversation behavior changes that would confuse users.

A new conversation (no `previous_response_id`) always picks up the latest version.

### Rollback API

```http
POST /v1/agents/agent_sec_analyst_7x9k2/rollback
Authorization: Bearer sk-platform-admin-key
Content-Type: application/json

{
  "target_version": 2
}
```

This creates a new version (version 4 in this case) whose content is identical to version 2. It does not rewrite history. The version history shows:

```
v1: Initial
v2: Added NVD MCP
v3: Updated compliance instructions
v4: Rollback to v2 (Added NVD MCP)
```

### Version Listing

```http
GET /v1/agents/agent_sec_analyst_7x9k2/versions?limit=10
```

Returns a paginated list of version snapshots with change metadata.

## 7. Integration with Other Platform Capabilities

Agent profiles act as the glue between Antwort's platform features. They provide a single place to configure how an agent interacts with every subsystem.

### With Sandbox Executor (Spec 11)

The profile's `sandbox_policy_id` determines what kind of sandbox Pods are created for this agent's code execution:

```json
{
  "sandbox_policy_id": "sbxpol_hardened_sec"
}
```

The sandbox policy (managed separately) defines:
- Container image (Python with security tools vs. data science packages)
- Resource limits (CPU, memory)
- Network policies (can it reach external APIs? internal services only?)
- Execution timeout
- Filesystem access restrictions

Different agents get different sandbox environments. The security analyst gets a hardened sandbox with network access to the NVD API. The data engineer gets a sandbox with pandas, numpy, and Snowflake connectivity. The docs writer gets no sandbox at all (no code execution).

### With Memory / Storage (Spec 05)

The profile's `memory` section configures how this agent remembers things:

```json
{
  "memory": {
    "vector_store_ids": ["vs_vuln_db_2025"],
    "conversation_retention_days": 90,
    "summary_enabled": true
  }
}
```

The storage layer uses these settings to:
- Attach the specified vector stores to file_search tool calls
- Automatically clean up conversations older than the retention period
- Generate and store conversation summaries for long-term recall

### With Scheduling (Future)

If Antwort gains scheduling capabilities (cron-triggered agent runs), schedules would reference agent profiles:

```json
{
  "schedule": "0 9 * * MON",
  "agent_id": "agent_sec_analyst_7x9k2",
  "input": [{"role": "user", "content": "Generate this week's vulnerability report"}],
  "delivery": {"type": "email", "to": "security-team@acme.com"}
}
```

### With Tool Registry (Spec 12)

Profiles reference tools by their registry ID. When a tool's implementation changes (new MCP server URL, updated function schema), the profile does not need updating. The tool registry provides indirection.

```json
{
  "tools": [
    {"type": "function", "registry_id": "tool_create_jira_ticket_v2"}
  ]
}
```

## 8. Storage

### PostgreSQL Schema

```sql
-- Agent profiles (current version)
CREATE TABLE agent_profiles (
    id          TEXT PRIMARY KEY,
    tenant_id   TEXT NOT NULL,
    name        TEXT NOT NULL,
    display_name TEXT,
    description TEXT,
    instructions TEXT NOT NULL,
    model       TEXT,
    tools       JSONB DEFAULT '[]'::jsonb,
    sandbox_policy_id TEXT,
    memory      JSONB,
    temperature DOUBLE PRECISION,
    top_p       DOUBLE PRECISION,
    max_output_tokens INTEGER,
    metadata    JSONB DEFAULT '{}'::jsonb,
    base_profile_id TEXT REFERENCES agent_profiles(id),
    status      TEXT NOT NULL DEFAULT 'active'
                CHECK (status IN ('active', 'archived')),
    version     INTEGER NOT NULL DEFAULT 1,
    created_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_by  TEXT NOT NULL,

    -- Unique name within a tenant
    CONSTRAINT uq_agent_name_tenant UNIQUE (tenant_id, name)
);

-- Indexes for common query patterns
CREATE INDEX idx_agent_profiles_tenant ON agent_profiles (tenant_id);
CREATE INDEX idx_agent_profiles_tenant_status ON agent_profiles (tenant_id, status);
CREATE INDEX idx_agent_profiles_name ON agent_profiles (tenant_id, name);
CREATE INDEX idx_agent_profiles_metadata ON agent_profiles USING gin (metadata);

-- Version history for rollback and audit
CREATE TABLE agent_profile_versions (
    id          BIGSERIAL PRIMARY KEY,
    agent_id    TEXT NOT NULL REFERENCES agent_profiles(id) ON DELETE CASCADE,
    version     INTEGER NOT NULL,
    snapshot    JSONB NOT NULL,
    changed_by  TEXT NOT NULL,
    changed_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
    change_summary TEXT,

    CONSTRAINT uq_agent_version UNIQUE (agent_id, version)
);

CREATE INDEX idx_agent_versions_agent ON agent_profile_versions (agent_id, version DESC);
```

### Design Notes

**JSONB for tools and metadata.** These fields have variable structure. Tools can be code_interpreter, file_search, MCP, or function definitions, each with different schemas. JSONB gives us flexibility without requiring EAV tables or separate tool-assignment tables.

**Tenant isolation.** Every query includes `tenant_id` in the WHERE clause. The index on `(tenant_id, status)` supports the most common query: "list all active agents for my tenant."

**GIN index on metadata.** Supports queries like "find all agents where metadata.team = 'security'". The GIN index makes JSONB containment queries (`@>`) efficient:

```sql
SELECT * FROM agent_profiles
WHERE tenant_id = 'tenant_acme'
  AND status = 'active'
  AND metadata @> '{"team": "platform-security"}'::jsonb;
```

**Version snapshots as JSONB.** The full profile state is stored as a JSONB blob in the versions table. This avoids needing to reconstruct historical state from a series of diffs. Each version is self-contained and can be restored directly.

**Soft delete.** Archiving sets `status = 'archived'` but keeps the row. The version history is preserved. Hard delete cascades to the versions table via `ON DELETE CASCADE`.

### Go Interface

```go
// AgentProfileStore defines storage operations for agent profiles.
type AgentProfileStore interface {
    // Create stores a new agent profile.
    Create(ctx context.Context, profile *AgentProfile) error

    // Get retrieves a profile by ID, scoped to tenant.
    Get(ctx context.Context, tenantID, agentID string) (*AgentProfile, error)

    // GetVersion retrieves a specific version of a profile.
    GetVersion(ctx context.Context, tenantID, agentID string, version int) (*AgentProfile, error)

    // List returns profiles matching the filter criteria.
    List(ctx context.Context, tenantID string, filter AgentListFilter) (*AgentProfileList, error)

    // Update performs a full replacement update with optimistic concurrency.
    // Returns ErrVersionConflict if the expected version does not match.
    Update(ctx context.Context, profile *AgentProfile, expectedVersion int) error

    // Patch performs a partial update.
    Patch(ctx context.Context, tenantID, agentID string, patch AgentPatch, expectedVersion int) error

    // Archive soft-deletes a profile.
    Archive(ctx context.Context, tenantID, agentID string) error

    // Delete permanently removes a profile and its version history.
    Delete(ctx context.Context, tenantID, agentID string) error

    // ListVersions returns the version history for a profile.
    ListVersions(ctx context.Context, tenantID, agentID string, limit, offset int) ([]AgentProfileVersion, error)
}
```

## 9. Authorization

### Scope Model

Agent profile operations require specific authorization scopes. These scopes integrate with the auth system from Spec 07.

| Scope | Allows |
|-------|--------|
| `agents:read` | GET /v1/agents, GET /v1/agents/{id} |
| `agents:write` | POST, PUT, PATCH /v1/agents |
| `agents:delete` | DELETE /v1/agents/{id} (soft delete) |
| `agents:admin` | Hard delete, manage profiles across all tenants |
| `agents:use` | Reference agent_id in Responses API requests |

### Role Mapping

| Role | Scopes | Typical User |
|------|--------|-------------|
| Platform Admin | `agents:read`, `agents:write`, `agents:delete`, `agents:admin`, `agents:use` | Platform engineering team |
| Agent Developer | `agents:read`, `agents:write`, `agents:use` | Teams that create and maintain agent profiles |
| Agent User | `agents:read`, `agents:use` | Application developers who use agents but do not modify them |
| Viewer | `agents:read` | Auditors, compliance officers |

### Per-Agent Access Control

For organizations that need fine-grained control, individual agent profiles can specify who can use them:

```json
{
  "id": "agent_sec_analyst_7x9k2",
  "access_control": {
    "allowed_subjects": ["user_alice", "user_bob", "group_security_team"],
    "denied_subjects": []
  }
}
```

If `access_control` is null or empty, the agent is available to anyone with the `agents:use` scope within the tenant. If `allowed_subjects` is specified, only those subjects can reference this agent in Responses API requests.

This is optional and off by default. Most organizations will rely on tenant-level isolation and scope-based access.

## 10. Concrete Examples

### Example 1: Security Analyst

```json
{
  "name": "security-analyst",
  "display_name": "Security Analyst",
  "description": "CVE triage, vulnerability assessment, and remediation recommendations",
  "instructions": "You are a senior security analyst at Acme Corp.\n\nYour primary responsibilities:\n1. Triage CVEs reported by automated scanners (Qualys, Snyk, Trivy)\n2. Assess impact on Acme's infrastructure by cross-referencing the asset inventory\n3. Produce actionable remediation recommendations\n4. Create Jira tickets for Critical and High severity findings\n\nClassification rules:\n- Critical: CVSS >= 9.0 AND affects production, OR known active exploitation\n- High: CVSS >= 7.0 AND affects production, OR CVSS >= 9.0 in staging\n- Medium: CVSS >= 4.0\n- Low: CVSS < 4.0 with no known exploit\n\nOutput format for each CVE:\n- CVE ID and CVSS score\n- Affected systems (from asset inventory search)\n- Exploitability assessment\n- Recommended remediation with timeline\n- Whether a Jira ticket should be created",
  "model": "llama-4-maverick",
  "tools": [
    {
      "type": "code_interpreter",
      "sandbox_policy_id": "sbxpol_hardened_sec"
    },
    {
      "type": "file_search",
      "vector_store_ids": ["vs_vuln_db_2025", "vs_asset_inventory"],
      "max_num_results": 20
    },
    {
      "type": "mcp",
      "server_label": "nvd-api",
      "server_url": "https://nvd.internal.acme.com/mcp",
      "allowed_tools": ["search_cve", "get_cve_details"],
      "require_approval": "never"
    },
    {
      "type": "function",
      "name": "create_jira_ticket",
      "description": "Create a tracking ticket in the SEC Jira project",
      "parameters": {
        "type": "object",
        "properties": {
          "title": {"type": "string"},
          "severity": {"type": "string", "enum": ["Critical", "High", "Medium", "Low"]},
          "cve_id": {"type": "string"},
          "description": {"type": "string"},
          "affected_systems": {"type": "array", "items": {"type": "string"}}
        },
        "required": ["title", "severity", "cve_id"]
      }
    }
  ],
  "sandbox_policy_id": "sbxpol_hardened_sec",
  "memory": {
    "vector_store_ids": ["vs_vuln_db_2025", "vs_asset_inventory"],
    "conversation_retention_days": 180,
    "summary_enabled": true
  },
  "temperature": 0.2,
  "max_output_tokens": 4096,
  "metadata": {
    "team": "platform-security",
    "compliance_level": "soc2"
  }
}
```

### Example 2: Data Engineer

```json
{
  "name": "data-engineer",
  "display_name": "Data Engineer",
  "description": "SQL query assistance, data pipeline debugging, and schema analysis for Snowflake",
  "instructions": "You are a data engineer specializing in Snowflake SQL and dbt models.\n\nCapabilities:\n- Write and optimize SQL queries against the Snowflake data warehouse\n- Debug failing dbt models by analyzing SQL compilation errors\n- Explain data lineage using our dbt documentation\n- Profile datasets for data quality issues\n\nRules:\n- Always use CTEs for complex queries. Never nest subqueries deeper than 2 levels.\n- Include a LIMIT clause in exploratory queries (default LIMIT 1000)\n- Never execute DELETE, DROP, TRUNCATE, or ALTER statements\n- Use the data dictionary vector store to understand column semantics\n- When writing queries, reference table and column names exactly as they appear in the schema\n- Prefer explicit JOINs over implicit comma-separated FROM clauses\n- Always include comments explaining the business logic behind complex WHERE clauses",
  "model": "llama-4-maverick",
  "tools": [
    {
      "type": "code_interpreter",
      "sandbox_policy_id": "sbxpol_data_science"
    },
    {
      "type": "file_search",
      "vector_store_ids": ["vs_data_dictionary", "vs_dbt_docs", "vs_sql_patterns"],
      "max_num_results": 15
    },
    {
      "type": "mcp",
      "server_label": "snowflake-readonly",
      "server_url": "https://snowflake-mcp.internal.acme.com/mcp",
      "allowed_tools": ["execute_query", "describe_table", "list_schemas"],
      "require_approval": "always"
    }
  ],
  "temperature": 0.3,
  "max_output_tokens": 8192,
  "metadata": {
    "team": "data-platform",
    "data_classification": "internal"
  }
}
```

### Example 3: Documentation Writer

```json
{
  "name": "docs-writer",
  "display_name": "Documentation Writer",
  "description": "Technical documentation author for API docs, runbooks, and architecture decision records",
  "instructions": "You are a technical writer at Acme Corp. You produce clear, precise documentation for engineering teams.\n\nDocumentation types you handle:\n- API reference documentation (OpenAPI-based)\n- Operational runbooks for on-call engineers\n- Architecture Decision Records (ADRs)\n- Internal knowledge base articles\n\nStyle guide:\n- Use active voice. Avoid passive constructions.\n- One sentence per line in AsciiDoc files (for clean git diffs).\n- Use second person ('you') for instructions, third person for descriptions.\n- Code examples must be complete and runnable, not pseudocode.\n- Every API endpoint must include request and response examples.\n- Use Acme's terminology: 'service' not 'microservice', 'team' not 'squad'.\n- Maximum heading depth: H4. If you need H5, restructure the document.\n\nFormatting:\n- Markdown for knowledge base articles\n- AsciiDoc for official documentation\n- Follow the existing document's format if editing",
  "model": "llama-4-maverick",
  "tools": [
    {
      "type": "file_search",
      "vector_store_ids": ["vs_existing_docs", "vs_style_guide"],
      "max_num_results": 10
    },
    {
      "type": "mcp",
      "server_label": "confluence",
      "server_url": "https://confluence-mcp.internal.acme.com/mcp",
      "allowed_tools": ["search_pages", "get_page_content", "create_page", "update_page"],
      "require_approval": "always"
    }
  ],
  "temperature": 0.5,
  "max_output_tokens": 16384,
  "metadata": {
    "team": "developer-experience",
    "output_format": "markdown"
  }
}
```

Note: No code_interpreter or sandbox. The docs writer has no code execution capability by design.

### Example 4: DevOps Assistant

```json
{
  "name": "devops-assistant",
  "display_name": "DevOps Assistant",
  "description": "Kubernetes cluster operations, incident response, and infrastructure debugging",
  "instructions": "You are a DevOps engineer at Acme Corp. You help the on-call team debug production issues and manage Kubernetes clusters.\n\nCapabilities:\n- Query cluster state via kubectl (read-only in production, read-write in staging)\n- Analyze Prometheus metrics and Grafana dashboards\n- Read application logs from Loki\n- Create and update incident tickets\n\nProduction safety rules:\n- NEVER run kubectl delete, kubectl edit, or kubectl apply in production clusters\n- Production access is strictly read-only: kubectl get, kubectl describe, kubectl logs only\n- Always confirm the target cluster before executing any command\n- When suggesting changes, write them as proposed kubectl commands for human review\n\nIncident response workflow:\n1. Gather symptoms (Pod status, events, logs, metrics)\n2. Identify the failing component\n3. Check recent Deployments and ConfigMap changes\n4. Propose root cause with supporting evidence\n5. Suggest remediation steps (but do not execute in production)\n6. Update the incident ticket with findings",
  "model": "llama-4-maverick",
  "tools": [
    {
      "type": "code_interpreter",
      "sandbox_policy_id": "sbxpol_devops"
    },
    {
      "type": "mcp",
      "server_label": "k8s-prod",
      "server_url": "https://k8s-mcp-prod.internal.acme.com/mcp",
      "allowed_tools": ["get_pods", "describe_pod", "get_events", "get_logs", "get_deployments", "get_services", "get_configmaps"],
      "require_approval": "never"
    },
    {
      "type": "mcp",
      "server_label": "prometheus",
      "server_url": "https://prom-mcp.internal.acme.com/mcp",
      "allowed_tools": ["query", "query_range", "alerts"],
      "require_approval": "never"
    },
    {
      "type": "function",
      "name": "update_incident_ticket",
      "description": "Update the incident ticket with current findings and status",
      "parameters": {
        "type": "object",
        "properties": {
          "incident_id": {"type": "string"},
          "status": {"type": "string", "enum": ["investigating", "identified", "monitoring", "resolved"]},
          "findings": {"type": "string"},
          "proposed_remediation": {"type": "string"}
        },
        "required": ["incident_id", "status", "findings"]
      }
    }
  ],
  "sandbox_policy_id": "sbxpol_devops",
  "memory": {
    "vector_store_ids": ["vs_runbooks", "vs_postmortems"],
    "conversation_retention_days": 365,
    "summary_enabled": true
  },
  "temperature": 0.1,
  "max_output_tokens": 8192,
  "metadata": {
    "team": "platform-operations",
    "on_call_integration": "pagerduty"
  }
}
```

Note: The DevOps assistant's sandbox policy (`sbxpol_devops`) would configure network policies allowing access to the Kubernetes API server and monitoring stack, but blocking access to databases and other sensitive internal services.

## 11. Migration from OpenClaw

### What OpenClaw Has

OpenClaw uses local markdown files for agent configuration:

- **SOUL.md**: Core personality and capabilities (maps to `instructions`)
- **IDENTITY.md**: Who the agent is, its role (also maps to `instructions`, essentially)
- **USER.md**: User-specific preferences (maps to per-request overrides or user-specific profiles)
- Tool configurations are scattered across the claw settings file

### Mapping to Agent Profiles

| OpenClaw File | Agent Profile Field | Notes |
|---------------|-------------------|-------|
| SOUL.md | `instructions` (first section) | Core personality and rules |
| IDENTITY.md | `instructions` (second section) + `display_name` + `description` | Role definition |
| USER.md | Per-user agent profile variant or request-level `instructions` override | User preferences |
| Tool config | `tools` array | Structured, not free-text |
| Model selection | `model` field | Explicit field |

### Import CLI Tool

A CLI tool could import OpenClaw markdown files into agent profiles:

```bash
# Import from OpenClaw directory structure
antwort agents import \
  --soul ./SOUL.md \
  --identity ./IDENTITY.md \
  --name "my-coding-assistant" \
  --model "llama-4-maverick" \
  --server https://antwort.acme.com \
  --api-key sk-platform-admin-key
```

The import logic:
1. Read SOUL.md and IDENTITY.md
2. Concatenate them with a separator into the `instructions` field
3. Apply the specified name and model
4. Create the profile via `POST /v1/agents`

Tool configurations would need manual mapping since OpenClaw's tool format is different from OpenResponses.

### What Improves Over OpenClaw

| OpenClaw | Antwort Agent Profiles |
|----------|----------------------|
| Local files on one machine | Server-side, accessible from anywhere |
| No version control (unless user commits to git) | Built-in versioning with rollback |
| No sharing mechanism | Tenant-scoped, team-wide access |
| No governance | Role-based access control, base templates |
| Tools configured separately | Tools bundled into the profile |
| No memory configuration | Memory and RAG settings included |
| Per-user only | Organization-managed with inheritance |

## 12. Open Questions

### Should agent profiles be Kubernetes CRDs?

**Option A: API-only (recommended for v1).**
Agent profiles live in PostgreSQL and are managed through the `/v1/agents` REST API. This keeps things simple and portable. Works in non-Kubernetes environments too.

**Option B: CRDs managed via kubectl.**
Agent profiles are `AgentProfile` custom resources in Kubernetes. Platform engineers manage them with `kubectl apply`, GitOps (ArgoCD/Flux), and standard Kubernetes tooling.

```yaml
apiVersion: antwort.dev/v1alpha1
kind: AgentProfile
metadata:
  name: security-analyst
  namespace: antwort
spec:
  displayName: Security Analyst
  instructions: |
    You are a senior security analyst...
  model: llama-4-maverick
  tools:
    - type: code_interpreter
      sandboxPolicyRef: hardened-sec
    - type: file_search
      vectorStoreIds:
        - vs_vuln_db_2025
  temperature: 0.2
```

Pros of CRDs: GitOps-native, Kubernetes RBAC for free, familiar to platform engineers.
Cons: Requires Kubernetes (Antwort might run outside K8s), CRD controllers add complexity, harder for application developers to interact with.

**Option C: Both.** The REST API is the primary interface. A Kubernetes operator syncs CRDs to the API. Platform engineers use kubectl, application developers use the REST API. The operator reconciles.

This is the most flexible but doubles the surface area. Probably not worth it for v1.

### How to handle cross-tenant profile sharing?

Some organizations have multiple tenants (dev, staging, prod) and want to share agent profiles across them. Options:

1. **Manual duplication.** Export a profile from one tenant, import to another. Simple but manual.
2. **Global profiles.** A special "global" tenant whose profiles are readable (but not writable) by all tenants. Platform admins manage global profiles.
3. **Profile references.** Profiles can reference a source profile in another tenant by a special cross-tenant ID. Changes propagate automatically.

Recommendation: Start with manual duplication (export/import). Add global profiles if demand emerges.

### Should there be a profile marketplace?

A marketplace for community agent profiles (like Helm charts or Terraform modules) is interesting but premature. It raises questions about trust, quality control, and security review. Probably a v2+ concern.

### How do profiles interact with the `store` parameter?

The Responses API has a `store` boolean that controls whether conversations are persisted. Should agent profiles have a default `store` value? If the security analyst profile always stores conversations (for audit), but a developer overrides `store: false` in the request, which wins?

Recommendation: Profile sets the default. Request overrides it. But profiles can also set `store_required: true` to prevent request-level opt-out. This supports compliance requirements.

### How large can instructions be?

The data model says 256KB. This is generous but bounded. Some agents might want to include entire style guides, code examples, or reference tables in their instructions. At 256KB, that is roughly 60,000 words, which should be sufficient for any reasonable prompt. If someone hits this limit, they should use file_search with a vector store for the reference material instead.

### Should profiles support conditional instructions?

Some teams want instructions that vary by context: "If the user is in the EU, follow GDPR guidelines. If the user is in the US, follow CCPA guidelines." This is achievable today by having separate profiles (security-analyst-eu, security-analyst-us) or by using request-level instruction overrides. A template/variable system within instructions would add complexity for marginal benefit.

Recommendation: No conditional instructions in v1. Use separate profiles or request-level overrides.
