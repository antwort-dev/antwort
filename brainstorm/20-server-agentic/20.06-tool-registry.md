# Brainstorm 06: Managed Tool Registry

**Related to**: Spec 04 (Agentic Loop, ToolExecutor), Spec 10 (MCP Client), Spec 11 (Sandbox), Brainstorm 12 (Function Provider Registry)
**Priority**: High (security differentiator)

## The Problem: Unvetted Tool Ecosystems Are Dangerous

OpenClaw's ClawHub showed what an open tools ecosystem looks like in practice. 2,857 community-contributed skills covered everything from Gmail and AWS to GitHub, calendars, and web scraping. Adoption was strong because developers could wire up integrations in minutes.

Then the security audit landed: **341 of 2,857 skills (12%) were malicious.** The breakdown:

- 143 skills exfiltrated conversation context to external servers
- 89 skills injected hidden prompt instructions that redirected model behavior
- 67 skills harvested API credentials from tool arguments and forwarded them
- 42 skills executed arbitrary code disguised as "data formatting" utilities

ClawHub had no review process, no permission model, no audit trail. Any user could publish a skill, and every other user could install it. Once installed, a skill had full access to everything the agent could see: conversation history, tool arguments (which often contain API keys, database queries, personal data), and the ability to make arbitrary HTTP requests.

A compromised tool in an agentic system is not like a compromised library in a traditional application. Traditional malware needs to find and extract secrets. A compromised tool receives secrets directly as function arguments and has a built-in communication channel (the tool's return value, which gets fed back to the model, or direct HTTP calls if network access is available).

Antwort needs a managed tool registry that preserves the ecosystem value (broad integrations, easy discovery, fast onboarding) while enforcing security through curation, per-tenant permissions, and audit trails.

## Tool Types in the Registry

The registry manages four categories of tools, each with different execution models:

### MCP Server Tools

MCP is the primary integration mechanism. Antwort already has an MCP client (`pkg/tools/mcp/`) that connects to MCP servers and discovers tools via `tools/list`. The registry adds a management layer on top:

- Which MCP servers are trusted sources
- Which individual tools from each server are approved for use
- Per-tenant access control for specific tools
- Audit logging of tool invocations

An MCP server like `mcp-server-github` might expose 30+ tools (create_issue, list_repos, merge_pr, etc.). The registry allows approving `list_repos` while blocking `delete_repo`, even though they come from the same server.

### Built-in Tools

Tools implemented within antwort as `FunctionProvider` implementations (Brainstorm 12). Examples: `web_search` (via SearXNG), `file_search` (via vector DB), `code_interpreter` (via sandbox). These are always available when enabled in config and are not managed through the registry. They have their own enable/disable mechanism via the `FunctionRegistry`.

The registry is aware of built-in tools (for discovery and documentation purposes) but does not control their lifecycle.

### Function Definitions (Client-Executed)

Schema-only tools where the client provides the definition and handles execution. This is the existing Responses API pattern: the client sends a `function` tool definition with a JSON Schema, the model produces `function_call` items, and the client executes them.

The registry can optionally store reusable function definitions as templates. An admin could publish a "standard CRM query" function definition that agents across the organization reference. But execution remains client-side, so the registry's security controls are limited to schema validation.

### Sandbox Tools

A new category for tools that need their own execution environment. These run inside Kubernetes sandbox Pods (Spec 11).

Examples:
- A "web-browser" tool that runs Playwright in a gVisor sandbox, with network access limited to specific domains
- A "kubectl" tool that runs kubectl commands inside a sandbox with K8s API access scoped to specific namespaces
- A "data-transform" tool that runs pandas/polars scripts on uploaded data

Sandbox tools are defined by a SandboxTemplate reference and an entrypoint. When invoked, antwort creates a SandboxClaim, runs the tool inside the Pod, and collects the result. They get the same isolation as `code_interpreter` (8-layer sandbox model from Spec 11).

## Registry Data Model

### Tool Entry

```go
type ToolEntry struct {
    // ID is auto-generated, prefixed "tool_" (e.g., "tool_8f3a2b1c").
    ID string `json:"id"`

    // Name is the unique human-readable identifier (e.g., "github-issues", "slack-search").
    // Must match [a-z0-9][a-z0-9-]{1,62}[a-z0-9].
    Name string `json:"name"`

    // Description explains what the tool does. This is shown to the LLM
    // for tool selection, so it must be clear and concise.
    Description string `json:"description"`

    // Source describes where the tool comes from and how to invoke it.
    Source ToolSource `json:"source"`

    // Schema is the JSON Schema for the tool's input parameters.
    Schema json.RawMessage `json:"schema"`

    // Permissions lists the capabilities this tool requires.
    Permissions []Permission `json:"permissions"`

    // SecurityStatus tracks the review state.
    SecurityStatus SecurityStatus `json:"security_status"`

    // Tags for categorization and filtering.
    Tags []string `json:"tags"`

    // TenantAccess controls which tenants can use this tool.
    TenantAccess TenantAccess `json:"tenant_access"`

    // AuditLevel controls how much invocation data is logged.
    AuditLevel AuditLevel `json:"audit_level"`

    // RateLimit restricts invocation frequency per tenant.
    RateLimit *RateLimit `json:"rate_limit,omitempty"`

    // Metadata
    CreatedAt  time.Time `json:"created_at"`
    UpdatedAt  time.Time `json:"updated_at"`
    ReviewedBy string    `json:"reviewed_by,omitempty"`
    ReviewedAt time.Time `json:"reviewed_at,omitempty"`
}
```

### Tool Source

```go
type ToolSource struct {
    // Type is one of: "mcp", "sandbox", "function", "builtin".
    Type string `json:"type"`

    // MCP fields (only when Type == "mcp")
    ServerURL string `json:"server_url,omitempty"`  // e.g., "https://mcp.internal/github"
    ServerName string `json:"server_name,omitempty"` // logical name, e.g., "github-mcp"
    ToolName  string `json:"tool_name,omitempty"`   // tool name on the MCP server

    // Sandbox fields (only when Type == "sandbox")
    Template   string `json:"template,omitempty"`    // SandboxTemplate name
    Entrypoint string `json:"entrypoint,omitempty"`  // command or script to run

    // Function fields (only when Type == "function")
    // Schema-only, client-executed. No source details needed beyond the schema.
}
```

### Permissions

```go
type Permission string

const (
    PermNetworkAccess    Permission = "network_access"     // can make HTTP requests
    PermNetworkInternal  Permission = "network_internal"   // can reach cluster-internal services
    PermNetworkExternal  Permission = "network_external"   // can reach the internet
    PermFileSystemRead   Permission = "filesystem_read"    // can read files
    PermFileSystemWrite  Permission = "filesystem_write"   // can write files
    PermKubernetesAPI    Permission = "kubernetes_api"     // can call K8s API
    PermDatabaseAccess   Permission = "database_access"    // can query databases
    PermSecretAccess     Permission = "secret_access"      // handles sensitive data (credentials, PII)
)
```

### Security Status

```go
type SecurityStatus string

const (
    SecurityUnreviewed SecurityStatus = "unreviewed"  // newly registered, not yet reviewed
    SecurityReviewed   SecurityStatus = "reviewed"    // reviewed but not yet approved
    SecurityApproved   SecurityStatus = "approved"    // reviewed and approved for use
    SecurityBlocked    SecurityStatus = "blocked"     // explicitly blocked (malicious or risky)
)
```

### Tenant Access

```go
type TenantAccess struct {
    // Mode determines the access control strategy.
    // "all" = available to all tenants (default for approved tools).
    // "allowlist" = only tenants in Allowlist can use this tool.
    // "denylist" = all tenants except those in Denylist can use this tool.
    Mode string `json:"mode"` // "all", "allowlist", "denylist"

    Allowlist []string `json:"allowlist,omitempty"`
    Denylist  []string `json:"denylist,omitempty"`
}
```

### Audit Level

```go
type AuditLevel string

const (
    AuditNone  AuditLevel = "none"   // no invocation logging
    AuditBasic AuditLevel = "basic"  // log tenant, tool, timestamp, duration, success/failure
    AuditFull  AuditLevel = "full"   // log input parameters and output (redacted where configured)
)
```

### Rate Limit

```go
type RateLimit struct {
    PerMinute int `json:"per_minute,omitempty"` // max invocations per minute per tenant
    PerHour   int `json:"per_hour,omitempty"`   // max invocations per hour per tenant
    PerDay    int `json:"per_day,omitempty"`     // max invocations per day per tenant
}
```

## Side-API: /v1/tools

The registry exposes a management API alongside the existing Responses API. All endpoints require authentication (Spec 07). Admin operations (review, delete) require an admin role.

### Register a Tool

```
POST /v1/tools
```

```json
{
  "name": "github-list-issues",
  "description": "List issues in a GitHub repository, filtered by state, labels, and assignee.",
  "source": {
    "type": "mcp",
    "server_url": "https://mcp.internal/github",
    "server_name": "github-mcp",
    "tool_name": "list_issues"
  },
  "schema": {
    "type": "object",
    "properties": {
      "owner": {"type": "string", "description": "Repository owner"},
      "repo": {"type": "string", "description": "Repository name"},
      "state": {"type": "string", "enum": ["open", "closed", "all"], "default": "open"},
      "labels": {"type": "array", "items": {"type": "string"}},
      "assignee": {"type": "string"}
    },
    "required": ["owner", "repo"]
  },
  "permissions": ["network_external"],
  "tags": ["development", "github", "issues"],
  "audit_level": "basic",
  "rate_limit": {
    "per_minute": 30,
    "per_hour": 500
  }
}
```

Response:

```json
{
  "id": "tool_8f3a2b1c",
  "name": "github-list-issues",
  "security_status": "unreviewed",
  "created_at": "2026-02-22T10:00:00Z",
  "..."
}
```

### List Tools

```
GET /v1/tools?type=mcp&tag=development&security_status=approved&limit=20&after=tool_xyz
```

Response:

```json
{
  "data": [
    {
      "id": "tool_8f3a2b1c",
      "name": "github-list-issues",
      "description": "List issues in a GitHub repository...",
      "source": {"type": "mcp", "server_name": "github-mcp"},
      "security_status": "approved",
      "tags": ["development", "github", "issues"],
      "created_at": "2026-02-22T10:00:00Z"
    }
  ],
  "has_more": false
}
```

### Get Tool Details

```
GET /v1/tools/tool_8f3a2b1c
```

Returns the full ToolEntry including schema, permissions, tenant access configuration, and audit settings.

### Update Tool Configuration

```
PUT /v1/tools/tool_8f3a2b1c
```

Updates mutable fields: description, schema, permissions, tags, tenant_access, audit_level, rate_limit. Does not change source or security_status (those have dedicated endpoints).

### Delete a Tool

```
DELETE /v1/tools/tool_8f3a2b1c
```

Removes the tool from the registry. Requires admin role.

### Review a Tool (Admin)

```
POST /v1/tools/tool_8f3a2b1c/review
```

```json
{
  "decision": "approved",
  "notes": "Reviewed source code. Only reads issue data, no write operations. Network access limited to GitHub API."
}
```

Valid decisions: `reviewed`, `approved`, `blocked`.

### Get Tool Usage Statistics

```
GET /v1/tools/tool_8f3a2b1c/usage?period=7d
```

```json
{
  "tool_id": "tool_8f3a2b1c",
  "period": "7d",
  "total_invocations": 1247,
  "unique_tenants": 8,
  "success_rate": 0.97,
  "avg_duration_ms": 342,
  "p99_duration_ms": 1850,
  "by_tenant": [
    {"tenant_id": "tenant_acme", "invocations": 523, "success_rate": 0.98},
    {"tenant_id": "tenant_globex", "invocations": 312, "success_rate": 0.96}
  ],
  "by_day": [
    {"date": "2026-02-15", "invocations": 189},
    {"date": "2026-02-16", "invocations": 201}
  ]
}
```

## MCP Server Management

### Registering an MCP Server as a Tool Source

Instead of listing MCP servers only in antwort's config file, the registry lets you register them via API. This enables dynamic MCP server management without restarting antwort.

```
POST /v1/tools/sources/mcp
```

```json
{
  "name": "github-mcp",
  "url": "https://mcp.internal/github",
  "auth": {
    "type": "api_key",
    "secret_ref": "mcp-github-api-key"
  },
  "auto_discover": true,
  "refresh_interval": "1h",
  "default_security_status": "unreviewed",
  "default_audit_level": "basic"
}
```

### Auto-Discovery Flow

When `auto_discover` is true:

1. Antwort connects to the MCP server and calls `tools/list`
2. For each discovered tool, a ToolEntry is created in the registry (if it doesn't already exist)
3. New tools start with `security_status: "unreviewed"` (or whatever `default_security_status` is configured)
4. Unreviewed tools are not available for use until an admin approves them
5. On each refresh cycle (`refresh_interval`), antwort re-discovers tools
6. New tools from the server get registered automatically
7. Tools that no longer exist on the server get marked as stale (not deleted, in case they come back)

### Per-Tool Overrides

After auto-discovery registers tools from a server, admins can override individual tools:

```
PUT /v1/tools/tool_8f3a2b1c
```

```json
{
  "tenant_access": {
    "mode": "allowlist",
    "allowlist": ["tenant_engineering"]
  },
  "rate_limit": {
    "per_minute": 10
  }
}
```

This lets you approve `github.list_issues` for everyone while restricting `github.delete_repo` to the engineering tenant with a tight rate limit.

### MCP Server Health Monitoring

The registry tracks MCP server health as a byproduct of discovery and execution:

- **Discovery health**: did the last `tools/list` call succeed?
- **Execution health**: what is the recent success rate for tools from this server?
- **Latency tracking**: are response times degrading?

This information is exposed via the `/v1/tools/sources/mcp/{name}/health` endpoint and as Prometheus metrics (`antwort_tool_registry_mcp_server_health`).

## Per-Tenant Permission Model

### Permission Hierarchy

Permissions flow from broad to narrow:

```
Global tool registry (what exists)
  -> Tenant-level access (what this tenant can see)
    -> Agent profile (what this agent is allowed to use)
      -> Request-level tools (what this specific request includes)
```

At each level, the set of available tools can only get smaller, never larger.

### Example: Three-Tenant Deployment

Consider a deployment with three tenants: `acme`, `globex`, and `initech`.

**Global registry** has 50 approved tools across GitHub, Slack, Jira, AWS, and internal APIs.

**Tenant-level**:
- `acme`: All 50 tools available (enterprise plan, no restrictions)
- `globex`: 30 tools available (blocked from AWS tools and internal APIs)
- `initech`: 15 tools available (trial plan, only productivity tools)

**Agent profile** (within acme):
- "Support Agent" profile: only Jira and Slack tools (10 of 50)
- "DevOps Agent" profile: GitHub, AWS, and Jira tools (25 of 50)
- "Research Agent" profile: web_search and file_search only (2 of 50)

**Request-level**: The client can further restrict tools per request using the existing `tools` field in the Responses API. If a client sends a request with only `["github-list-issues"]`, the agent can only use that one tool even if its profile allows 25.

### Runtime Enforcement

When the engine prepares to execute a tool call during the agentic loop:

```go
func (r *ToolRegistry) AuthorizeTool(ctx context.Context, toolName string) error {
    entry, ok := r.GetTool(toolName)
    if !ok {
        return ErrToolNotFound
    }

    // 1. Is the tool approved?
    if entry.SecurityStatus != SecurityApproved {
        return ErrToolNotApproved
    }

    // 2. Is the tenant allowed?
    tenant := storage.GetTenant(ctx)
    if !r.tenantAllowed(entry, tenant) {
        return ErrTenantDenied
    }

    // 3. Is the rate limit exceeded?
    if entry.RateLimit != nil && r.rateLimitExceeded(entry, tenant) {
        return ErrRateLimitExceeded
    }

    return nil
}
```

This check happens after the model selects a tool but before the executor runs it. If authorization fails, the engine feeds an error result back to the model (per Spec 04 FR-027), and the model can choose a different tool or respond without one.

## Security Review Workflow

### Review States

```
unreviewed -> reviewed -> approved
                       -> blocked

approved -> blocked (if a problem is discovered later)
blocked -> approved (after fixes)
```

### Security Checklist for Reviewers

When reviewing a tool, the admin should evaluate:

**1. Schema Injection Risk**

Does the tool's input schema allow free-text fields that could be used for prompt injection? For example, a tool with a `query` parameter of type `string` with no validation is higher risk than one with an `enum` parameter.

Risk indicators:
- Unrestricted string parameters (especially ones named "query", "prompt", "instruction")
- Parameters that accept code or scripts
- Parameters with no length limits

**2. Network Access**

What network access does the tool require?

- No network access (pure computation): low risk
- Internal network only (cluster services): medium risk, verify which services
- External network (internet): high risk, verify which domains
- Unrestricted external network: very high risk, almost certainly should be blocked

**3. Data Handling**

What data does the tool receive and produce?

- Does it receive sensitive data in its arguments (API keys, passwords, PII)?
- Does it store data externally?
- Does it transmit data to third-party services?
- Are its outputs filtered or sanitized?

**4. MCP Server Trust**

For MCP tools, who operates the MCP server?

- First-party (operated by the same organization as antwort): higher trust
- Third-party with SLA: medium trust
- Unknown/community: low trust, requires thorough review

### Automated Checks

Before human review, automated checks can flag obvious problems:

```go
type AutoReviewResult struct {
    Score       int      // 0-100, higher is safer
    Flags       []string // issues found
    Suggestions []string // recommended actions
}

func AutoReview(entry ToolEntry) AutoReviewResult {
    var flags []string

    // Check for unrestricted string parameters
    schema := parseSchema(entry.Schema)
    for _, prop := range schema.Properties {
        if prop.Type == "string" && prop.MaxLength == 0 && prop.Pattern == "" {
            flags = append(flags, fmt.Sprintf(
                "parameter %q is an unrestricted string (no maxLength, no pattern)",
                prop.Name,
            ))
        }
    }

    // Check for dangerous permission combinations
    if hasPermission(entry, PermNetworkExternal) && hasPermission(entry, PermSecretAccess) {
        flags = append(flags, "tool has both external network access and secret access")
    }

    // Check for known-bad patterns in description
    if containsInjectionPattern(entry.Description) {
        flags = append(flags, "tool description contains suspicious patterns")
    }

    // ...
}
```

These automated checks produce a safety score and flag list. Tools with a score below a threshold require mandatory human review. Tools with a perfect score could be auto-approved in low-security deployments.

## Tool Execution Audit Trail

### Audit Record

Every tool invocation generates an audit record (when `audit_level` is not `none`):

```go
type ToolAuditRecord struct {
    // Identity
    ID        string    `json:"id"`         // "audit_9x8w7v6u"
    Timestamp time.Time `json:"timestamp"`

    // Who
    TenantID string `json:"tenant_id"`
    AgentID  string `json:"agent_id,omitempty"`  // if agent profiles are used
    UserID   string `json:"user_id,omitempty"`   // if user identity is available

    // What
    ToolID   string `json:"tool_id"`
    ToolName string `json:"tool_name"`
    CallID   string `json:"call_id"`  // from the model's function_call

    // How it went
    Status   string  `json:"status"`        // "success", "error", "rate_limited", "denied"
    Duration float64 `json:"duration_ms"`

    // Input/Output (only for audit_level "full")
    InputArgs  json.RawMessage `json:"input_args,omitempty"`
    OutputSize int             `json:"output_size,omitempty"`
    Output     string          `json:"output,omitempty"`  // truncated to max 10KB
    Error      string          `json:"error,omitempty"`

    // Context
    ResponseID string `json:"response_id"` // the Responses API response this call belongs to
}
```

### Querying Audit Records

```
GET /v1/tools/audit?tenant_id=tenant_acme&tool_name=github-list-issues&after=2026-02-15&limit=100
```

This is useful for:
- Compliance reporting ("show me all tool invocations by tenant X in the last 30 days")
- Debugging ("why did this agent call this tool 500 times in one hour?")
- Cost attribution ("how many API calls did each tenant generate through MCP tools?")
- Incident response ("which tenants used this tool before we blocked it?")

### Retention Policy

Audit records can have per-tenant retention policies:

```json
{
  "tenant_id": "tenant_acme",
  "audit_retention": {
    "basic_records": "90d",
    "full_records": "30d"
  }
}
```

Basic records (no input/output) are kept for 90 days. Full records (with input/output) are kept for 30 days due to their size and sensitivity.

## Tool Bundles

### Concept

Individual tool management works for small catalogs, but at scale (50+ tools), assigning tools one by one to agents and tenants becomes tedious. Tool bundles group related tools into named collections.

### Bundle Definition

```json
{
  "id": "bundle_github",
  "name": "GitHub Suite",
  "description": "Complete GitHub integration: issues, PRs, repos, actions, and code search",
  "tools": [
    "tool_8f3a2b1c",
    "tool_2d4e6f8a",
    "tool_1b3c5d7e",
    "tool_9a8b7c6d",
    "tool_4e5f6a7b"
  ],
  "tags": ["development", "github"]
}
```

### Bundle Operations

```
POST /v1/tools/bundles                    Create a bundle
GET  /v1/tools/bundles                    List bundles
GET  /v1/tools/bundles/{id}               Get bundle details (with resolved tool list)
PUT  /v1/tools/bundles/{id}               Update bundle
DELETE /v1/tools/bundles/{id}             Delete bundle
POST /v1/tools/bundles/{id}/assign        Assign bundle to a tenant or agent profile
```

### Assignment Example

Assign the GitHub Suite to the engineering tenant's "DevOps Agent" profile:

```json
POST /v1/tools/bundles/bundle_github/assign
{
  "tenant_id": "tenant_engineering",
  "agent_profile": "devops-agent"
}
```

Now every agent instance using the "devops-agent" profile in the engineering tenant automatically gets access to all five GitHub tools. When a new tool is added to the bundle, it's immediately available to all assigned agents (assuming the tool itself is approved).

## Relationship to Existing Architecture

### Current State (Without Registry)

```
Config file:
  mcp_servers:
    - name: github-mcp
      url: https://mcp.internal/github

On startup:
  MCPExecutor connects to github-mcp
  MCPExecutor calls tools/list
  MCPExecutor caches discovered tools

On request:
  Engine receives tools from request + MCP discovered tools
  Model selects a tool
  MCPExecutor executes it
  No permission check, no audit, no rate limit
```

### With Registry

```
Admin registers MCP server via API:
  POST /v1/tools/sources/mcp {name: "github-mcp", url: "...", auto_discover: true}

Registry connects to github-mcp, discovers 30 tools:
  Creates 30 ToolEntry records with security_status: "unreviewed"

Admin reviews and approves 25 tools, blocks 5:
  POST /v1/tools/tool_xyz/review {decision: "approved"}
  POST /v1/tools/tool_abc/review {decision: "blocked", notes: "deletes repos"}

On request:
  Engine receives tools from request
  Engine merges with registry-approved tools for this tenant
  Model selects a tool
  Registry checks: approved? tenant allowed? rate limit OK?
  MCPExecutor executes it (same as before)
  Registry logs audit record
```

The MCPExecutor itself doesn't change. The registry sits in front of it, controlling which tools are available and logging what happens.

### Migration Path

Existing deployments that configure MCP servers in the config file can continue doing so. The registry is an optional layer. Config-based MCP servers bypass the registry's permission and review system (they're implicitly trusted since the admin configured them). The registry becomes relevant when:

- You want per-tenant tool access control
- You want to block specific tools from an MCP server
- You want audit trails for tool invocations
- You're connecting to MCP servers you don't fully trust

## Sandbox Tools (New Category)

### Why Sandbox Tools?

Some tools need capabilities that don't fit the MCP model. An MCP server is a remote HTTP service that receives a request and returns a result. But what about tools that need:

- A full browser environment (Playwright, Puppeteer)
- Kubernetes API access with specific RBAC permissions
- Local file system access to process uploaded documents
- A Python runtime with specific packages installed
- GPU access for inference or image processing

These tools need their own execution environment. Sandbox tools run inside Kubernetes Pods managed by agent-sandbox (Spec 11).

### Sandbox Tool Definition

```json
{
  "name": "web-browser",
  "description": "Browse a web page and extract content. Supports JavaScript rendering.",
  "source": {
    "type": "sandbox",
    "template": "antwort-browser",
    "entrypoint": "/usr/local/bin/browse"
  },
  "schema": {
    "type": "object",
    "properties": {
      "url": {"type": "string", "description": "URL to browse"},
      "selector": {"type": "string", "description": "CSS selector to extract (optional)"},
      "wait_for": {"type": "string", "description": "CSS selector to wait for before extraction"}
    },
    "required": ["url"]
  },
  "permissions": ["network_external"],
  "tags": ["web", "scraping"]
}
```

The corresponding SandboxTemplate (Kubernetes resource):

```yaml
apiVersion: sandbox.k8s.io/v1alpha1
kind: SandboxTemplate
metadata:
  name: antwort-browser
spec:
  podTemplate:
    spec:
      containers:
      - name: browser
        image: ghcr.io/rhuss/antwort-sandbox-browser:latest
        ports:
        - containerPort: 8080
        resources:
          limits:
            cpu: "2"
            memory: 2Gi
        securityContext:
          runAsNonRoot: true
          readOnlyRootFilesystem: true
      # Network policy restricts outbound to allowed domains only
```

### Execution Flow

1. Model calls `web-browser` tool with `{"url": "https://example.com"}`
2. Registry checks: approved? tenant allowed? rate limit OK?
3. Sandbox executor creates a SandboxClaim for the `antwort-browser` template
4. agent-sandbox allocates a Pod from the warm pool (or creates one)
5. Antwort sends the tool arguments to the Pod via its REST API: `POST /execute`
6. Pod runs the entrypoint with the arguments, returns the result
7. Antwort feeds the result back to the model
8. SandboxClaim is released (Pod returns to pool for reuse)

### Security for Sandbox Tools

Sandbox tools inherit the full isolation model from Spec 11:

- gVisor runtime class for kernel isolation
- Network policies restricting outbound traffic per tool
- Resource limits (CPU, memory, ephemeral storage)
- Non-root execution with read-only root filesystem
- SPIFFE/SPIRE mTLS between antwort and sandbox Pod
- No Kubernetes API access unless explicitly granted

The key difference from code_interpreter is that sandbox tools have pre-defined, reviewed entrypoints. A code_interpreter sandbox runs arbitrary user code. A sandbox tool runs a specific, audited program with validated inputs.

## Credential Management for Tools

### The Problem

Many MCP tools need credentials to function. The GitHub MCP server needs a GitHub token. The Slack MCP server needs a Slack bot token. The AWS MCP server needs IAM credentials.

In a multi-tenant deployment, different tenants may need different credentials for the same MCP server (tenant A's GitHub org vs. tenant B's GitHub org).

### Credential Sources

```
Tenant credential store:
  tenant_acme:
    github_token: "ghp_acme_xxx"
    slack_token: "xoxb_acme_yyy"
  tenant_globex:
    github_token: "ghp_globex_xxx"
    slack_token: "xoxb_globex_yyy"
```

Credentials are stored in Kubernetes Secrets (one Secret per tenant) and injected into MCP requests via the MCPAuthProvider (Brainstorm 10-mcp-security).

### Per-Tenant Credential Binding

The registry associates tools with credential requirements, and tenants provide their own credentials:

```json
{
  "name": "github-list-issues",
  "source": {
    "type": "mcp",
    "server_name": "github-mcp",
    "credential_key": "github_token"
  }
}
```

When tenant `acme` invokes `github-list-issues`, the registry looks up `github_token` in acme's credential store and passes it to the MCP auth provider. Tenant `globex` gets its own token.

This keeps credentials isolated per tenant without the MCP server needing multi-tenancy support.

## Open Questions

### Centralized vs. Federated Registry

Should the registry be deployment-local only, or should deployments be able to subscribe to upstream registries (like pulling container images from a registry)?

**Centralized (per-deployment)**:
- Simpler implementation
- Full control over what's available
- No external dependencies
- Admin must manually register every tool

**Federated (subscribe to upstream)**:
- Organization-wide tool catalog shared across deployments
- Community registries (like Docker Hub for tools)
- Faster onboarding for new deployments
- Risk of upstream compromise (need signature verification)

For v1, centralized is the right choice. Federation can be added later if there's demand.

### Tool Versioning

MCP servers may update their tool schemas without warning. A `list_issues` tool might add a new required parameter, breaking existing agent workflows.

Options:
- **Ignore it**: Always use the latest schema from the MCP server. Simple but risky.
- **Pin schemas**: Store the approved schema in the registry. If the MCP server's schema changes, flag it for re-review.
- **Semantic versioning**: Track tool versions and allow agents to pin specific versions.

Schema pinning seems like the right middle ground. The registry stores the approved schema. On each discovery refresh, if the MCP server's schema has changed, the tool's status changes to `unreviewed` and an admin is notified.

### OAuth Credential Flow

For tools that require per-user OAuth tokens (not just per-tenant API keys), the credential management gets more complex. Consider a "Google Calendar" tool where each user needs their own OAuth token.

Options:
- **Token exchange** (Brainstorm 10b): Antwort exchanges the user's JWT for a Google OAuth token via the IdP
- **Credential vault**: Users register their OAuth tokens in a vault, antwort retrieves them at runtime
- **Out of scope**: Tools requiring per-user OAuth are implemented as client-executed functions instead

Token exchange is the cleanest approach and is already designed in Brainstorm 10b. The registry just needs to declare that a tool requires user-level credentials and specify which token exchange audience to use.

### Relationship to Agent Profiles

This brainstorm assumes agent profiles exist (mentioned in the permission hierarchy), but agent profiles are not yet designed. The tool registry should not depend on agent profiles, it should work with tenant-level permissions alone. Agent profiles are an additional restriction layer when they arrive.

## Package Structure

```
pkg/tools/
├── registry/                    # Existing: FunctionProvider + FunctionRegistry
│   ├── registry.go
│   ├── provider.go
│   └── middleware.go
├── catalog/                     # NEW: Managed tool catalog
│   ├── catalog.go               # ToolCatalog (stores ToolEntry records)
│   ├── entry.go                 # ToolEntry, ToolSource, Permission, etc.
│   ├── review.go                # Security review workflow
│   ├── audit.go                 # ToolAuditRecord, audit logging
│   ├── ratelimit.go             # Per-tenant rate limiting
│   ├── bundle.go                # ToolBundle grouping
│   ├── api.go                   # HTTP handlers for /v1/tools
│   ├── discovery.go             # MCP auto-discovery integration
│   └── catalog_test.go
├── mcp/                         # Existing: MCP client
│   ├── executor.go
│   ├── client.go
│   └── auth.go
├── builtins/                    # Existing: Built-in providers
│   └── websearch/
└── filter.go                    # Existing: allowed_tools filtering
```

The `catalog` package is new. It wraps the existing `registry` (for built-in tools) and `mcp` (for MCP tools) packages, adding management, permissions, and auditing on top. The existing packages continue to work unchanged.

## Deliverables

- [ ] ToolEntry data model and storage (in-memory + PostgreSQL via storage interface)
- [ ] /v1/tools CRUD API (register, list, get, update, delete)
- [ ] Security review workflow (unreviewed -> reviewed -> approved/blocked)
- [ ] MCP server registration and auto-discovery
- [ ] Per-tenant access control (allowlist/denylist)
- [ ] Runtime tool authorization (check before execution)
- [ ] Audit trail logging (basic and full modes)
- [ ] Rate limiting per tenant per tool
- [ ] Tool bundles (grouping and assignment)
- [ ] Automated security checks (schema analysis, permission flagging)
- [ ] Sandbox tool type support (SandboxTemplate reference, entrypoint)
- [ ] Migration path from config-based MCP to registry-managed MCP
- [ ] Prometheus metrics for registry operations
