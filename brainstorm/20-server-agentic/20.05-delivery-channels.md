# Brainstorm: Delivery Channels

**Status**: Brainstorm
**Dependencies**: Spec 02 (Transport Layer), Spec 04 (Agentic Loop), Spec 05 (Storage)
**Related**: OpenClaw multi-channel gateway, Scheduled Agents (future spec)

## Context

OpenClaw's most compelling UX feature is "the agent meets you where you are": WhatsApp, Telegram, Slack, Discord, and more. Users interact with agents in their preferred messaging platform, and OpenClaw bridges the gap.

For a server-native platform like Antwort, the model is fundamentally different. The primary interface is the Responses API (the data plane). Delivery channels are an *output mechanism* that pushes results to additional destinations after a response is produced. This distinction matters most for scheduled or proactive agents that have no client waiting for a response. A nightly data analysis agent, for example, runs on a cron schedule, produces results via the Responses API, and then delivers a summary to a Slack channel and an email to the team lead.

The key insight: Antwort does not replace the Responses API with channel-based interaction. Instead, delivery channels extend the Responses API by routing results to additional destinations.

## 1. The Server-Side Delivery Model

### How It Differs from OpenClaw

OpenClaw receives messages FROM channels (Slack message -> agent invocation -> response -> Slack reply). The channel is both input and output. The user's message arrives through the channel, and the response goes back through the same channel.

Antwort pushes results TO channels. The Responses API remains the single entry point for all agent invocations. Delivery channels are a post-processing step: after a response is produced, the delivery subsystem routes the response content to configured destinations.

```
OpenClaw Model:
  Slack message -> OpenClaw -> LLM -> OpenClaw -> Slack reply

Antwort Model:
  API request -> Antwort -> LLM -> API response
                                  \-> Slack notification
                                  \-> Webhook POST
                                  \-> Email
```

### When Delivery Channels Activate

Delivery channels are relevant in three scenarios:

1. **Scheduled executions**: An agent runs on a cron schedule (e.g., every morning at 8am). There is no HTTP client waiting for the response. The results must go somewhere.

2. **Background/async responses**: A long-running agentic loop completes minutes after the original request. The client may have disconnected. Delivery channels ensure the results reach the intended audience.

3. **Notification rules**: A response matches certain conditions (e.g., contains an error, exceeds a cost threshold, mentions a keyword), and a notification is sent to a configured channel.

### Fan-Out

A single response can be delivered to zero, one, or multiple channels simultaneously. A nightly report might go to:
- A Slack channel (#daily-reports) as a formatted message
- An email to the team lead with the full response as an attachment
- A webhook to an internal dashboard for ingestion

Zero channels is the default: the Responses API is always the primary interface, and delivery is opt-in.

## 2. Channel Types

Ordered by implementation priority.

### 2.1 Webhook (Priority: P0)

The most flexible channel type. Covers any custom integration by POSTing response content to a URL.

**Why first**: Webhook is the universal adapter. Any system that can receive HTTP requests can integrate. This single channel type covers hundreds of potential integrations without Antwort needing to know anything about the target system.

**Configuration**:
```json
{
  "kind": "webhook",
  "name": "internal-dashboard",
  "config": {
    "url": "https://dashboard.internal.example.com/api/agent-results",
    "method": "POST",
    "headers": {
      "X-Source": "antwort"
    },
    "auth": {
      "type": "bearer",
      "token_secret": "webhook-dashboard-token"
    },
    "payload_format": "full",
    "timeout_seconds": 30,
    "retry": {
      "max_attempts": 3,
      "backoff_base_seconds": 2
    }
  }
}
```

**Payload formats**:
- `full`: The complete response JSON as returned by the Responses API
- `summary`: A reduced payload with response ID, status, model, and extracted text content
- `template`: A custom Go template applied to the response object

**Authentication options**:
- `bearer`: Authorization header with a bearer token (token value referenced from a Kubernetes Secret)
- `hmac`: HMAC-SHA256 signature of the request body in a configurable header
- `header`: Arbitrary headers (e.g., API keys, custom auth schemes)
- `none`: No authentication

**Retry behavior**: On HTTP 5xx or connection failure, retry with exponential backoff. 4xx responses are not retried (they indicate a configuration problem). Max attempts configurable, default 3.

### 2.2 Slack (Priority: P1)

Post to a Slack channel or DM via the Slack API.

**Configuration**:
```json
{
  "kind": "slack",
  "name": "team-alerts",
  "config": {
    "channel": "#agent-results",
    "bot_token_secret": "slack-bot-token",
    "format": "blocks",
    "thread_behavior": "new",
    "include_files": true
  }
}
```

**Features**:
- **Rich formatting**: Convert response text content to Slack Block Kit blocks. Code blocks become Slack code blocks. Markdown headings become bold text sections.
- **Thread support**: `thread_behavior` controls threading. `new` creates a new message. `thread` posts as a reply to the most recent message from this agent in the channel (useful for scheduled agents that produce daily results). `update` edits the previous message in place.
- **File attachment**: If the response includes `code_interpreter` output with generated files, upload them to Slack as file attachments on the message.
- **Mention support**: The message template can include Slack user mentions for alerting.

**Authentication**: Slack bot token stored in a Kubernetes Secret. The bot must be installed in the workspace and invited to the target channel.

### 2.3 Email (Priority: P1)

Send response content via email.

**Configuration**:
```json
{
  "kind": "email",
  "name": "team-lead-report",
  "config": {
    "to": ["lead@example.com"],
    "cc": [],
    "from": "antwort-agent@example.com",
    "subject_template": "Agent Report: {{.Model}} - {{.Status}}",
    "body_format": "html",
    "include_attachments": true,
    "smtp": {
      "host": "smtp.example.com",
      "port": 587,
      "auth_secret": "smtp-credentials"
    }
  }
}
```

**Alternative**: Instead of raw SMTP, support API-based email providers (SendGrid, Amazon SES) as sub-types of the email channel.

**Formatting**: Response content rendered as HTML email. Code blocks get syntax highlighting. File outputs attached as email attachments.

### 2.4 Microsoft Teams (Priority: P2)

Post via Teams incoming webhook or Microsoft Graph API.

**Configuration**:
```json
{
  "kind": "teams",
  "name": "engineering-channel",
  "config": {
    "webhook_url_secret": "teams-webhook-url",
    "format": "adaptive_card",
    "card_template": "default"
  }
}
```

**Formatting**: Response content formatted as an Adaptive Card. The default template shows the agent name, model, status, and response text. Custom templates allow per-channel card layouts.

### 2.5 Google Chat (Priority: P2)

Post via Google Chat webhook or Chat API.

**Configuration**:
```json
{
  "kind": "google_chat",
  "name": "team-space",
  "config": {
    "webhook_url_secret": "gchat-webhook-url",
    "format": "card"
  }
}
```

### 2.6 Custom (Priority: P3)

A pluggable adapter interface for additional channels. See Section 6 for the adapter interface.

## 3. Channel Configuration Side-API: `/v1/channels`

The Channels API is a management-plane API for configuring delivery channels. It sits alongside the Responses API (data plane) and the Agent Profiles API (control plane).

### Endpoints

| Method | Path | Description |
|--------|------|-------------|
| POST | `/v1/channels` | Create a channel configuration |
| GET | `/v1/channels` | List all channels |
| GET | `/v1/channels/{id}` | Get channel details |
| PUT | `/v1/channels/{id}` | Update a channel |
| DELETE | `/v1/channels/{id}` | Delete a channel |
| POST | `/v1/channels/{id}/test` | Send a test message |

### Create Channel

```
POST /v1/channels
Content-Type: application/json

{
  "kind": "webhook",
  "name": "internal-dashboard",
  "config": {
    "url": "https://dashboard.internal.example.com/api/agent-results",
    "auth": {
      "type": "bearer",
      "token_secret": "webhook-dashboard-token"
    },
    "payload_format": "full",
    "retry": {
      "max_attempts": 3,
      "backoff_base_seconds": 2
    }
  },
  "metadata": {
    "team": "platform",
    "environment": "production"
  }
}
```

**Response**:
```json
{
  "id": "ch_abc123",
  "kind": "webhook",
  "name": "internal-dashboard",
  "config": { "..." },
  "status": "unverified",
  "created_at": "2026-02-22T10:00:00Z",
  "metadata": {
    "team": "platform",
    "environment": "production"
  }
}
```

### List Channels

```
GET /v1/channels?kind=slack&status=verified
```

**Response**:
```json
{
  "data": [
    {
      "id": "ch_def456",
      "kind": "slack",
      "name": "team-alerts",
      "status": "verified",
      "created_at": "2026-02-20T14:30:00Z",
      "last_delivery_at": "2026-02-22T08:00:00Z",
      "delivery_count": 42
    }
  ]
}
```

### Test Channel

Sends a synthetic test message to verify connectivity and credentials.

```
POST /v1/channels/ch_def456/test
Content-Type: application/json

{
  "message": "Test message from Antwort. If you see this, the channel is working."
}
```

**Response**:
```json
{
  "status": "success",
  "delivered_at": "2026-02-22T10:05:00Z",
  "channel_response": {
    "status_code": 200,
    "body": "ok"
  }
}
```

On success, the channel status changes from `unverified` to `verified`.

### Channel Status Lifecycle

```
unverified -> verified (after successful test or first successful delivery)
verified -> degraded (after N consecutive delivery failures)
degraded -> verified (after successful delivery)
any -> disabled (manual or automatic after persistent failures)
```

## 4. Delivery Rules

Delivery rules define which responses go to which channels, under what conditions.

### 4.1 Configuration Levels

Delivery can be configured at three levels, with lower levels overriding higher ones:

**Agent profile level**: Default channels for all responses produced by this agent profile.

```json
{
  "agent_profile": "nightly-analyst",
  "delivery": {
    "channels": ["ch_def456", "ch_ghi789"],
    "conditions": {
      "on": "always"
    }
  }
}
```

**Schedule level**: Channels for responses produced by a specific schedule. Overrides agent profile defaults.

```json
{
  "schedule": {
    "cron": "0 8 * * *",
    "agent_profile": "nightly-analyst",
    "delivery": {
      "channels": ["ch_def456"],
      "conditions": {
        "on": "success"
      },
      "failure_channels": ["ch_oncall_webhook"],
      "failure_conditions": {
        "on": "failure"
      }
    }
  }
}
```

**Request level**: Per-request delivery hints, passed via the `extensions` field on the Responses API request.

```json
{
  "model": "gpt-4o",
  "input": "Analyze today's sales data",
  "extensions": {
    "delivery": {
      "channels": ["ch_def456"],
      "conditions": {
        "on": "always"
      },
      "content_filter": "summary"
    }
  }
}
```

### 4.2 Delivery Conditions

| Condition | Fires when |
|-----------|-----------|
| `always` | Every completed response (success or failure) |
| `success` | Response status is `completed` |
| `failure` | Response status is `failed` or `incomplete` |
| `error_only` | Response contains error items |
| `custom` | A Go expression evaluating response fields (future) |

### 4.3 Content Filtering

Control what parts of the response are included in the delivery:

| Filter | Included content |
|--------|-----------------|
| `full` | Complete response output (all items) |
| `summary` | Text content only, truncated to channel limits |
| `text_only` | Only `output_text` items, no tool calls or metadata |
| `errors_only` | Only error items and status |
| `custom` | A Go template selecting specific fields |

### 4.4 Merge Behavior

When delivery is configured at multiple levels:

1. Request-level delivery, if present, *replaces* all other levels (not merged)
2. Schedule-level delivery, if present, *replaces* agent profile defaults
3. Agent profile delivery is the fallback

This "replace, don't merge" behavior keeps the mental model simple. If you specify delivery at the request level, you are explicitly choosing the channels for this request.

## 5. Message Formatting

### 5.1 The Formatting Pipeline

```
Response object
  -> Content extraction (apply content_filter)
  -> Template rendering (apply channel-specific template)
  -> Size enforcement (truncate to channel limits)
  -> Delivery
```

### 5.2 Content Extraction

The content extractor walks the response output items and produces a `DeliveryContent` struct:

```go
type DeliveryContent struct {
    ResponseID string
    Status     string
    Model      string

    // Extracted text content (from output_text items)
    Text       string

    // Extracted code blocks (from code_interpreter output)
    CodeBlocks []CodeBlock

    // Generated files (from code_interpreter or file outputs)
    Files      []FileRef

    // Error details (if status is failed/incomplete)
    Error      *ErrorDetail

    // Raw response for templates that need full access
    Raw        *api.Response
}
```

### 5.3 Per-Channel Templates

Each channel type has a default template and supports custom templates.

**Slack default template** (Block Kit):
```json
[
  {
    "type": "header",
    "text": {
      "type": "plain_text",
      "text": "Agent Response: {{.Status}}"
    }
  },
  {
    "type": "section",
    "text": {
      "type": "mrkdwn",
      "text": "{{.Text | truncate 3000}}"
    }
  },
  {
    "type": "context",
    "elements": [
      {
        "type": "mrkdwn",
        "text": "Model: {{.Model}} | Response: {{.ResponseID}}"
      }
    ]
  }
]
```

**Email default template** (HTML):
```html
<html>
<body>
  <h2>Agent Response: {{.Status}}</h2>
  <div class="content">{{.Text | markdown_to_html}}</div>
  {{range .CodeBlocks}}
  <pre><code class="{{.Language}}">{{.Code}}</code></pre>
  {{end}}
  <hr>
  <p style="color: #666; font-size: 12px;">
    Model: {{.Model}} | Response ID: {{.ResponseID}}
  </p>
</body>
</html>
```

**Webhook default template** (JSON):
```json
{
  "response_id": "{{.ResponseID}}",
  "status": "{{.Status}}",
  "model": "{{.Model}}",
  "text": "{{.Text}}",
  "timestamp": "{{.Timestamp}}"
}
```

### 5.4 Channel-Specific Size Limits

| Channel | Max message size | Truncation strategy |
|---------|-----------------|---------------------|
| Slack | 3,000 chars per block, 50 blocks | Split into multiple messages if needed |
| Email | No practical limit | Include full content |
| Webhook | Configurable (default: no limit) | Configurable truncation |
| Teams | 28 KB per Adaptive Card | Truncate text, link to full response |
| Google Chat | 4,096 chars per message | Truncate with "view full response" link |

### 5.5 Handling Code Interpreter Output

Code interpreter output needs special treatment per channel:

- **Slack**: Code blocks rendered in triple backtick blocks. Generated plots uploaded as image attachments. CSV files uploaded as file attachments.
- **Email**: Code blocks in `<pre><code>` tags. Plots embedded as inline images. Files as email attachments.
- **Webhook**: Code blocks and file references included in the JSON payload. File content can optionally be base64-encoded inline or referenced by URL.
- **Teams**: Code blocks in Adaptive Card code block elements. Files linked by URL.

## 6. The Delivery Adapter Interface

```go
// DeliveryAdapter handles delivery to a specific channel type.
// Each adapter knows how to format, authenticate, and deliver
// messages for its channel kind.
type DeliveryAdapter interface {
    // Kind returns the channel type this adapter handles
    // (e.g., "webhook", "slack", "email").
    Kind() string

    // Deliver sends a message to the channel. The message has
    // already been formatted by the template engine. The adapter
    // handles authentication, transport, and error handling.
    Deliver(ctx context.Context, msg DeliveryMessage) (*DeliveryResult, error)

    // Validate checks that the channel configuration is valid
    // for this adapter (e.g., URL is reachable, token format is
    // correct). Called when a channel is created or updated.
    Validate(ctx context.Context, config ChannelConfig) error

    // FormatContent transforms DeliveryContent into the channel-
    // specific format. For Slack, this produces Block Kit JSON.
    // For email, this produces HTML. For webhooks, this produces
    // the configured payload format.
    FormatContent(content DeliveryContent, template string) ([]byte, error)
}
```

### Supporting Types

```go
// DeliveryMessage is the fully prepared message ready for delivery.
type DeliveryMessage struct {
    ChannelID   string          // ID of the target channel configuration
    ChannelKind string          // "webhook", "slack", "email", etc.
    Config      ChannelConfig   // Channel-specific configuration
    Content     DeliveryContent // Extracted response content
    Formatted   []byte          // Channel-formatted payload (output of FormatContent)
    Metadata    map[string]string
}

// DeliveryResult captures the outcome of a delivery attempt.
type DeliveryResult struct {
    Status       DeliveryStatus // delivered, failed, retried
    Timestamp    time.Time
    Attempts     int
    ChannelRef   string // Channel-specific reference (e.g., Slack message ts)
    ErrorMessage string // Empty on success
}

// DeliveryStatus tracks the state of a delivery.
type DeliveryStatus int

const (
    DeliveryPending   DeliveryStatus = iota
    DeliveryDelivered
    DeliveryFailed
    DeliveryRetrying
)

// ChannelConfig holds channel-specific configuration.
// The Config field is a json.RawMessage that each adapter
// knows how to parse for its channel kind.
type ChannelConfig struct {
    ID       string            `json:"id"`
    Kind     string            `json:"kind"`
    Name     string            `json:"name"`
    Config   json.RawMessage   `json:"config"`
    Metadata map[string]string `json:"metadata,omitempty"`
}
```

### Adapter Registration

Adapters are registered at startup. New adapters can be added without changing the engine or delivery subsystem.

```go
// DeliveryRegistry manages available delivery adapters.
type DeliveryRegistry struct {
    mu       sync.RWMutex
    adapters map[string]DeliveryAdapter
}

func (r *DeliveryRegistry) Register(adapter DeliveryAdapter) {
    r.mu.Lock()
    defer r.mu.Unlock()
    r.adapters[adapter.Kind()] = adapter
}

func (r *DeliveryRegistry) Get(kind string) (DeliveryAdapter, bool) {
    r.mu.RLock()
    defer r.mu.RUnlock()
    a, ok := r.adapters[kind]
    return a, ok
}
```

### Delivery Orchestrator

The delivery orchestrator is the central component that coordinates delivery across multiple channels for a single response.

```go
// DeliveryOrchestrator handles delivery of a response to all
// configured channels. It resolves delivery rules, extracts
// content, formats per channel, and dispatches to adapters.
type DeliveryOrchestrator struct {
    registry *DeliveryRegistry
    store    DeliveryStore  // persists delivery status
    logger   *slog.Logger
}

// DeliverResponse fans out a response to all matching channels.
// It runs deliveries concurrently and collects results.
func (o *DeliveryOrchestrator) DeliverResponse(
    ctx context.Context,
    resp *api.Response,
    rules []DeliveryRule,
) []DeliveryResult {
    // 1. Evaluate rules to find matching channels
    // 2. Extract content from response (apply content_filter)
    // 3. For each channel (concurrently):
    //    a. Get adapter from registry
    //    b. Format content for channel
    //    c. Deliver
    //    d. Record result
    // 4. Return all results
}
```

## 7. Bidirectional Channels (Future Vision)

### Phase 1: Output Only (This Spec)

Phase 1 covers output-only delivery. Antwort pushes response content to channels after processing. The Responses API remains the only input mechanism.

### Future: Input from Channels

In a future phase, channels could accept incoming messages and translate them into Responses API requests. This would make Antwort a full multi-channel agent gateway.

```
Future Model:
  Slack message -> Antwort Channel Ingress -> Responses API -> LLM -> Response
                                                                      \-> Slack reply
                                                                      \-> Webhook
```

This is essentially what OpenClaw does, but server-side and integrated with the Responses API.

### Designing for Bidirectionality

Even though Phase 1 is output-only, the adapter interface should accommodate future input support. The approach: define an optional `Receiver` interface that adapters can implement when input support is added.

```go
// ChannelReceiver is an optional interface that delivery adapters
// can implement to support receiving messages from a channel.
// Not required in Phase 1. This is a future extension point.
type ChannelReceiver interface {
    // SetupIngress registers the channel's incoming message handler.
    // For Slack, this sets up the Events API webhook or Socket Mode.
    // For webhooks, this creates an endpoint that accepts incoming POSTs.
    SetupIngress(ctx context.Context, handler IngressHandler) error

    // TeardownIngress removes the incoming message handler.
    TeardownIngress(ctx context.Context) error
}

// IngressHandler processes incoming messages from channels.
type IngressHandler func(ctx context.Context, msg IngressMessage) error

// IngressMessage represents a message received from a channel.
type IngressMessage struct {
    ChannelID   string
    ChannelKind string
    SenderID    string // Channel-specific sender identifier
    SenderName  string
    Text        string
    ThreadRef   string // Channel-specific thread reference
    Timestamp   time.Time
    Raw         json.RawMessage // Original channel payload
}
```

Key design decision: `DeliveryAdapter` and `ChannelReceiver` are separate interfaces. An adapter that only does output (Phase 1) implements `DeliveryAdapter`. An adapter that supports both directions (future) implements both `DeliveryAdapter` and `ChannelReceiver`. This avoids forcing all adapters to implement input handling.

## 8. Security Considerations

### Credential Storage

All channel credentials (bot tokens, API keys, webhook URLs with embedded secrets, SMTP passwords) are stored in Kubernetes Secrets. The channel configuration references Secret names, never inline credential values.

```json
{
  "kind": "slack",
  "config": {
    "bot_token_secret": "antwort-slack-bot-token"
  }
}
```

The delivery subsystem reads the Secret value at delivery time (not at configuration time). This means Secret rotation takes effect immediately without reconfiguring the channel.

### Content Sensitivity

Response content may contain sensitive data (PII, credentials, internal system details). Each channel configuration includes an optional `content_policy` that controls what is delivered:

```json
{
  "content_policy": {
    "redact_patterns": ["\\b\\d{3}-\\d{2}-\\d{4}\\b"],
    "max_content_length": 5000,
    "strip_tool_calls": true,
    "strip_metadata": true
  }
}
```

### Audit Logging

Every delivery attempt is logged with structured fields:

```go
slog.Info("delivery completed",
    "channel_id", channelID,
    "channel_kind", "slack",
    "response_id", responseID,
    "status", "delivered",
    "duration_ms", duration.Milliseconds(),
    "attempts", attempts,
)
```

All delivery records are persisted in the delivery store for audit purposes. They include: channel ID, response ID, timestamp, status, number of attempts, and error details on failure.

### Rate Limiting

Each channel adapter respects the target platform's rate limits:

| Platform | Rate limit | Antwort behavior |
|----------|-----------|-----------------|
| Slack | 1 msg/sec per channel | Queue and space deliveries |
| Teams | Varies by webhook type | Configurable delay between messages |
| Email/SMTP | Depends on provider | Configurable send rate |
| Webhook | Unlimited by default | Configurable per-channel rate limit |

The rate limiter is per-channel, not global. Two Slack channels can each receive 1 msg/sec concurrently.

## 9. Observability

### Metrics

```
# Counter: total delivery attempts
antwort_delivery_total{channel_kind="slack", status="delivered"} 142
antwort_delivery_total{channel_kind="slack", status="failed"} 3
antwort_delivery_total{channel_kind="webhook", status="delivered"} 1089

# Histogram: delivery duration (seconds)
antwort_delivery_duration_seconds{channel_kind="slack"} (p50=0.3, p99=2.1)
antwort_delivery_duration_seconds{channel_kind="webhook"} (p50=0.1, p99=0.8)

# Gauge: channels by status
antwort_channels_status{kind="slack", status="verified"} 3
antwort_channels_status{kind="webhook", status="degraded"} 1
```

### Delivery Status Tracking

Each delivery attempt is recorded in the delivery store:

```go
type DeliveryRecord struct {
    ID          string
    ResponseID  string
    ChannelID   string
    ChannelKind string
    Status      DeliveryStatus
    Attempts    int
    CreatedAt   time.Time
    DeliveredAt *time.Time
    Error       string
    ChannelRef  string // e.g., Slack message timestamp
}
```

### Alerting

Failed deliveries should trigger alerts. Suggested alerting rules:

- **Channel degraded**: 3 consecutive failures for the same channel -> mark channel as `degraded`, emit alert
- **Channel disabled**: 10 consecutive failures -> mark channel as `disabled`, emit alert, stop attempting delivery
- **Delivery backlog**: More than 100 pending deliveries -> emit alert (indicates a systemic problem)

## 10. Integration Points

### With the Responses API

The delivery subsystem hooks into the response lifecycle. When a response reaches a terminal state (`completed`, `failed`, `incomplete`), the engine checks for applicable delivery rules and dispatches to the delivery orchestrator.

```go
// In engine.go, after response completion:
func (e *Engine) finalizeResponse(ctx context.Context, resp *api.Response) {
    // ... existing finalization logic ...

    // Trigger delivery if rules are configured
    rules := e.resolveDeliveryRules(ctx, resp)
    if len(rules) > 0 {
        // Run delivery asynchronously, don't block response return
        go e.deliveryOrchestrator.DeliverResponse(ctx, resp, rules)
    }
}
```

### With Storage

Delivery records need their own storage. The `DeliveryStore` interface:

```go
type DeliveryStore interface {
    // SaveChannel persists a channel configuration.
    SaveChannel(ctx context.Context, channel ChannelConfig) error

    // GetChannel retrieves a channel by ID.
    GetChannel(ctx context.Context, id string) (*ChannelConfig, error)

    // ListChannels lists all channels, optionally filtered.
    ListChannels(ctx context.Context, filter ChannelFilter) ([]ChannelConfig, error)

    // DeleteChannel removes a channel configuration.
    DeleteChannel(ctx context.Context, id string) error

    // RecordDelivery saves a delivery attempt record.
    RecordDelivery(ctx context.Context, record DeliveryRecord) error

    // GetDeliveries retrieves delivery records for a response.
    GetDeliveries(ctx context.Context, responseID string) ([]DeliveryRecord, error)
}
```

### With Scheduled Agents (Future)

Scheduled agents (a future spec) will be the primary consumer of delivery channels. The schedule configuration will reference channel IDs:

```json
{
  "schedule": {
    "cron": "0 8 * * MON-FRI",
    "agent_profile": "daily-summary",
    "input": "Generate the daily summary report",
    "delivery": {
      "channels": ["ch_slack_reports", "ch_email_lead"],
      "conditions": { "on": "always" }
    }
  }
}
```

## 11. Open Questions

### Synchronous vs Asynchronous Delivery

**Option A: Fully asynchronous (fire-and-forget)**
- The response is returned to the API client immediately. Delivery happens in a background goroutine.
- Pro: No latency impact on API responses.
- Con: The client doesn't know if delivery succeeded.

**Option B: Synchronous for scheduled, async for API requests**
- API requests: async (the client gets the response directly).
- Scheduled executions: synchronous (delivery failures are recorded as part of the execution result).
- Pro: Scheduled agents can track delivery status.
- Con: More complex.

**Option C: Async with status polling**
- All delivery is async, but the response object includes a `delivery_status` field that the client can poll.
- Pro: Clean separation. Client can check delivery status if it cares.
- Con: Adds a field to the response object.

**Current leaning**: Option C. Async delivery with a `delivery_status` field on the response. The field is only present when delivery rules are configured.

### Delivery Failure Handling for Scheduled Agents

When a scheduled agent produces a response but delivery fails, what happens?

- **Option 1**: Retry delivery on the next schedule tick (risk: stale data)
- **Option 2**: Log the failure and move on (risk: lost results)
- **Option 3**: Queue failed deliveries for retry with a separate retry worker (complexity, but correct)
- **Option 4**: Deliver to a fallback channel (e.g., always deliver to a "dead letter" webhook)

**Current leaning**: Option 3 with Option 4 as a configurable safety net.

### Bidirectional in Phase 1?

Should any channel support incoming messages in Phase 1?

**Argument for**: Slack bidirectional is the most requested feature for agent platforms. Supporting it from day one would be a strong differentiator.

**Argument against**: Bidirectional changes the security model significantly (Antwort needs to authenticate incoming channel users, map them to API users, handle rate limiting from channel users). This is a large scope increase.

**Current leaning**: No. Phase 1 is output-only. Design the interface for future bidirectional support, but don't implement it yet.

### Response API Extension

Should the Responses API response object include delivery information?

```json
{
  "id": "resp_abc123",
  "status": "completed",
  "output": [ "..." ],
  "delivery": {
    "status": "pending",
    "channels": [
      {
        "channel_id": "ch_def456",
        "status": "delivered",
        "delivered_at": "2026-02-22T10:05:00Z"
      },
      {
        "channel_id": "ch_ghi789",
        "status": "retrying",
        "attempts": 2,
        "last_error": "connection timeout"
      }
    ]
  }
}
```

**Pro**: Single place to check response status and delivery status.
**Con**: Pollutes the Responses API with non-standard fields. The `delivery` field would need to go in the `extensions` object to stay compatible with the OpenResponses spec.

**Current leaning**: Put delivery status in `extensions.delivery` on the response object. Make it opt-in (only present when the response has delivery rules).

### Channel Lifecycle

When a channel is deleted, what happens to pending deliveries?

- **Option 1**: Cancel all pending deliveries for that channel
- **Option 2**: Complete pending deliveries, then delete
- **Option 3**: Block deletion if there are pending deliveries

**Current leaning**: Option 1. Deleting a channel cancels pending deliveries. The delivery records remain in the store for audit purposes with status `cancelled`.

## 12. Implementation Phases

| Phase | Scope | Priority |
|-------|-------|----------|
| Phase 1a | Webhook adapter, delivery orchestrator, `/v1/channels` API | P0 |
| Phase 1b | Slack adapter, email adapter | P1 |
| Phase 2 | Teams adapter, Google Chat adapter, custom adapter interface | P2 |
| Phase 3 | Bidirectional channels (input from Slack, etc.) | P3 |
| Phase 4 | Advanced features (content policies, template marketplace) | P3 |

Phase 1a is the foundation. The webhook adapter alone covers a huge range of integrations, and the orchestrator and API are reusable for all future channel types.
