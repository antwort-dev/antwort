# Brainstorm: Server-Native Agent Platform Overview

**Created**: 2026-02-22
**Status**: Brainstorm (pre-spec)
**Scope**: Cross-cutting overview linking all platform capability brainstorms

## Vision

Antwort evolves from an OpenResponses API gateway into a **server-native agent platform** that absorbs the best ideas from OpenClaw while fixing its fundamental security and scalability limitations. The Responses API remains the primary runtime interface (data plane). Platform capabilities that don't fit naturally into the Responses API are exposed via side-APIs (control plane).

For the full vision rationale, see [specs/vision-agent-platform.md](../specs/vision-agent-platform.md).
For the blog-style narrative, see [blog-server-native-agent-platform.md](../blog-server-native-agent-platform.md).

## Platform Brainstorm Documents

These documents extend the existing brainstorm series (01-14) with platform capabilities:

| # | Document | Phase | Description |
|---|----------|-------|-------------|
| 01 | [Sandbox Executor](01-sandbox-executor.md) | 1 | Kubernetes-native code execution via agent-sandbox CRDs. The foundation capability. |
| 02 | [Agent Profiles](02-agent-profiles.md) | 2 | Reusable agent configurations (server-side SOUL.md). Side-API + Responses API bridge. |
| 03 | [Memory & Knowledge](03-memory-knowledge.md) | 3 | Vector stores for RAG, episodic memory, conversation summarization. |
| 04 | [Proactive Scheduling](04-proactive-scheduling.md) | 4 | Cron triggers, webhook triggers, completion hooks. Autonomous agents. |
| 05 | [Delivery Channels](05-delivery-channels.md) | 5 | Push results to Slack, Teams, email, webhooks. Multi-channel output. |
| 06 | [Tool Registry](06-tool-registry.md) | 6 | Curated, security-audited tool catalog with per-tenant permissions. |
| 07 | [Security Model](07-security-model.md) | Cross-cutting | Threat model, defense in depth, multi-tenant isolation, audit logging. |

Note: Documents 01-07 in this series overlap in numbering with the existing infrastructure brainstorms (01-core-protocol, 02-transport, etc.). The platform documents focus on new capabilities that extend the existing infrastructure. The sandbox executor (01) replaces the earlier sandbox brainstorm (11-sandbox.md) with a more comprehensive design grounded in the OpenClaw analysis.

## Dependency Graph

```
                    ┌──────────────────┐
                    │  07 Security     │ (cross-cutting, informs all others)
                    │  Model           │
                    └────────┬─────────┘
                             │
                    ┌────────▼─────────┐
                    │  01 Sandbox      │ ◄── Foundation: everything builds on this
                    │  Executor        │
                    └────────┬─────────┘
                             │
                    ┌────────▼─────────┐
                    │  02 Agent        │ ◄── References sandbox policies
                    │  Profiles        │
                    └───┬────┬────┬────┘
                       │    │    │
              ┌────────▼┐ ┌▼────┴───┐
              │03 Memory│ │06 Tool  │ ◄── Agent profiles reference both
              │Knowledge│ │Registry │
              └─────────┘ └─────────┘
                       │
              ┌────────▼─────────┐
              │  04 Proactive    │ ◄── Schedules reference agent profiles
              │  Scheduling      │
              └────────┬─────────┘
                       │
              ┌────────▼─────────┐
              │  05 Delivery     │ ◄── Scheduled agents need delivery targets
              │  Channels        │
              └──────────────────┘
```

## API Surface Summary

### Data Plane (Responses API, spec-compliant)

All runtime interactions flow through the standard Responses API. Platform features integrate via:

- `tools: [{"type": "code_interpreter"}]` triggers sandbox execution (01)
- `tools: [{"type": "file_search", "vector_store_ids": [...]}]` triggers RAG retrieval (03)
- `agent_id` field loads stored agent profile (02)
- `previous_response_id` provides conversation memory (existing)
- `extensions` field carries platform-specific metadata (non-breaking)

### Control Plane (Side-APIs)

| Endpoint | Document | Purpose |
|----------|----------|---------|
| `/v1/agents` | 02 | CRUD for agent profiles |
| `/v1/sandboxes` | 01 | Sandbox policy configuration |
| `/v1/vector_stores` | 03 | Knowledge base management |
| `/v1/schedules` | 04 | Cron/webhook/completion triggers |
| `/v1/channels` | 05 | Delivery channel configuration |
| `/v1/tools` | 06 | Tool registry management |

## Key Design Decisions

1. **Data plane stays pure.** The Responses API is never broken for existing clients. All extensions are additive (new optional fields, extensions map).

2. **Secure by default.** No unsandboxed code execution path. gVisor isolation, NetworkPolicy deny-all, mTLS with SPIFFE/SPIRE. (Details in 01, 07)

3. **agent-sandbox CRDs for Pod management.** Antwort does not implement its own Pod lifecycle controllers. It consumes `Sandbox`, `SandboxClaim`, `SandboxWarmPool`, `SandboxTemplate` from kubernetes-sigs/agent-sandbox. (Details in 01)

4. **Python first, BYO-ready.** Ship with Python 3.12+ sandbox image. Any image implementing the sandbox REST API contract works. (Details in 01)

5. **Session-scoped sandboxes as default.** Pod persists across tool calls within a conversation. State carries over (packages, files, variables). (Details in 01)

6. **Agent profiles are API resources, not CRDs.** Managed via `/v1/agents` side-API, stored in PostgreSQL. Consistent with the existing storage model. (Details in 02)

7. **pgvector as default vector store.** Same PostgreSQL database, keeps the dependency footprint small. Interface allows alternative backends. (Details in 03)

8. **Internal scheduler first.** Cron triggers run within the antwort process. Kubernetes CronJobs as an alternative for HA deployments. (Details in 04)

9. **Webhook as the universal delivery adapter.** Ship with webhook delivery first. Slack, Teams, and email adapters follow. (Details in 05)

10. **Tool registry wraps existing MCP integration.** The registry adds management (review, permissions, audit) on top of the existing MCP client. No changes to the MCP client itself. (Details in 06)

## Build Order

| Phase | Capability | What It Delivers | Spec Dependencies |
|-------|-----------|-----------------|-------------------|
| 1 | Sandbox Executor | Secure `code_interpreter` via K8s Pods. Any OpenAI SDK works. | Specs 001-017 |
| 2 | Agent Profiles | Reusable agent configs. `agent_id` in requests. | Phase 1 |
| 3 | Memory & Knowledge | RAG via `file_search`. Conversation summarization. | Phase 2 |
| 4 | Scheduling | Cron, webhooks, completion hooks. Autonomous agents. | Phase 2 |
| 5 | Delivery Channels | Push results to Slack, Teams, email, webhooks. | Phase 4 |
| 6 | Tool Registry | Managed tool catalog with security review. | Phase 1 |

**Phases 1-2 are the MVP.** They deliver secure, multi-tenant code execution with managed agent configurations, accessible through a standard API. No other open-source project provides this today.

## Next Steps

1. Review brainstorm documents for completeness and accuracy
2. Prioritize open questions from each document
3. Write formal specs (using the SDD workflow) starting with Phase 1
4. Update the project constitution if needed for new principles
5. Begin implementation of the sandbox executor
